<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Design Patterns</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A catalogue of Rust design patterns, anti-patterns and idioms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="idioms/index.html"><strong aria-hidden="true">2.</strong> 习语</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/coercion-arguments.html"><strong aria-hidden="true">2.1.</strong> 使用借用类型作为参数</a></li><li class="chapter-item expanded "><a href="idioms/concat-format.html"><strong aria-hidden="true">2.2.</strong> Concatenating Strings with format!</a></li><li class="chapter-item expanded "><a href="idioms/ctor.html"><strong aria-hidden="true">2.3.</strong> Constructor</a></li><li class="chapter-item expanded "><a href="idioms/default.html"><strong aria-hidden="true">2.4.</strong> The Default Trait</a></li><li class="chapter-item expanded "><a href="idioms/deref.html"><strong aria-hidden="true">2.5.</strong> Collections Are Smart Pointers</a></li><li class="chapter-item expanded "><a href="idioms/dtor-finally.html"><strong aria-hidden="true">2.6.</strong> Finalisation in Destructors</a></li><li class="chapter-item expanded "><a href="idioms/mem-replace.html"><strong aria-hidden="true">2.7.</strong> mem::{take(), replace()}</a></li><li class="chapter-item expanded "><a href="idioms/on-stack-dyn-dispatch.html"><strong aria-hidden="true">2.8.</strong> On-Stack Dynamic Dispatch</a></li><li class="chapter-item expanded "><a href="idioms/ffi/intro.html"><strong aria-hidden="true">2.9.</strong> Foreign function interface (FFI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/ffi/errors.html"><strong aria-hidden="true">2.9.1.</strong> Idiomatic Errors</a></li><li class="chapter-item expanded "><a href="idioms/ffi/accepting-strings.html"><strong aria-hidden="true">2.9.2.</strong> Accepting Strings</a></li><li class="chapter-item expanded "><a href="idioms/ffi/passing-strings.html"><strong aria-hidden="true">2.9.3.</strong> Passing Strings</a></li></ol></li><li class="chapter-item expanded "><a href="idioms/option-iter.html"><strong aria-hidden="true">2.10.</strong> Iterating over an Option</a></li><li class="chapter-item expanded "><a href="idioms/pass-var-to-closure.html"><strong aria-hidden="true">2.11.</strong> Pass Variables to Closure</a></li><li class="chapter-item expanded "><a href="idioms/priv-extend.html"><strong aria-hidden="true">2.12.</strong> Privacy For Extensibility</a></li><li class="chapter-item expanded "><a href="idioms/rustdoc-init.html"><strong aria-hidden="true">2.13.</strong> Easy doc initialization</a></li><li class="chapter-item expanded "><a href="idioms/temporary-mutability.html"><strong aria-hidden="true">2.14.</strong> Temporary mutability</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> 设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/behavioural/intro.html"><strong aria-hidden="true">3.1.</strong> 行为型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/behavioural/command.html"><strong aria-hidden="true">3.1.1.</strong> 命令</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/interpreter.html"><strong aria-hidden="true">3.1.2.</strong> 解释器</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/newtype.html"><strong aria-hidden="true">3.1.3.</strong> 新类型</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/RAII.html"><strong aria-hidden="true">3.1.4.</strong> RAII守护对象</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/strategy.html"><strong aria-hidden="true">3.1.5.</strong> 策略</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/visitor.html"><strong aria-hidden="true">3.1.6.</strong> 访问者</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/creational/intro.html"><strong aria-hidden="true">3.2.</strong> Creational</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/creational/builder.html"><strong aria-hidden="true">3.2.1.</strong> Builder</a></li><li class="chapter-item expanded "><a href="patterns/creational/fold.html"><strong aria-hidden="true">3.2.2.</strong> Fold</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/structural/intro.html"><strong aria-hidden="true">3.3.</strong> Structural</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/structural/compose-structs.html"><strong aria-hidden="true">3.3.1.</strong> Compose Structs</a></li><li class="chapter-item expanded "><a href="patterns/structural/small-crates.html"><strong aria-hidden="true">3.3.2.</strong> Prefer Small Crates</a></li><li class="chapter-item expanded "><a href="patterns/structural/unsafe-mods.html"><strong aria-hidden="true">3.3.3.</strong> Contain unsafety in small modules</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/ffi/intro.html"><strong aria-hidden="true">3.4.</strong> Foreign function interface (FFI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/ffi/export.html"><strong aria-hidden="true">3.4.1.</strong> Object-Based APIs</a></li><li class="chapter-item expanded "><a href="patterns/ffi/wrappers.html"><strong aria-hidden="true">3.4.2.</strong> Type Consolidation into Wrappers</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="anti_patterns/index.html"><strong aria-hidden="true">4.</strong> 反面模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="anti_patterns/borrow_clone.html"><strong aria-hidden="true">4.1.</strong> 通过Clone来满足借用检查器</a></li><li class="chapter-item expanded "><a href="anti_patterns/deny-warnings.html"><strong aria-hidden="true">4.2.</strong> #[deny(warnings)]</a></li><li class="chapter-item expanded "><a href="anti_patterns/deref.html"><strong aria-hidden="true">4.3.</strong> 解引用多态性</a></li></ol></li><li class="chapter-item expanded "><a href="functional/index.html"><strong aria-hidden="true">5.</strong> Functional Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functional/paradigms.html"><strong aria-hidden="true">5.1.</strong> Programming paradigms</a></li><li class="chapter-item expanded "><a href="functional/generics-type-classes.html"><strong aria-hidden="true">5.2.</strong> Generics as Type Classes</a></li></ol></li><li class="chapter-item expanded "><a href="additional_resources/index.html"><strong aria-hidden="true">6.</strong> Additional Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="additional_resources/design-principles.html"><strong aria-hidden="true">6.1.</strong> Design principles</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust Design Patterns</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/Fomalhauthmj/patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<h2 id="参与"><a class="header" href="#参与">参与</a></h2>
<p>如果你有兴趣为这本书做贡献，请查阅
<a href="https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md">贡献指南</a>.</p>
<h2 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h2>
<p>在开发程序时，我们必须解决许多问题。
一个程序可以被看作是一个问题的解决方案。
它也可以被看作是许多问题的解决方案的集合。
所有这些解决方案一起工作，以解决更大的问题。</p>
<h2 id="rust中的设计模式"><a class="header" href="#rust中的设计模式">Rust中的设计模式</a></h2>
<p>有许多问题具有相同的形式。
由于Rust不是面向对象的，设计模式与其他面向对象的编程语言不同。
虽然细节不同，但由于它们具有相同的形式，因此可以用相同的基本方法来解决：</p>
<ul>
<li><a href="./patterns/index.html">设计模式</a>是解决编写软件时常见问题的方法。</li>
<li><a href="./anti_patterns/index.html">反面模式</a>是解决这些相同的常见问题的方法。然而，在设计模式给我们带来好处的同时，反面模式却带来了更多的问题。</li>
<li><a href="./idioms/index.html">习语</a>是编码时要遵循的准则。
它们是社区的社会规范。
你可以打破它们，但如果你这样做，你应该有一个好的理由。</li>
</ul>
<p>TODO：提到为什么Rust有点特别--函数式元素、类型系统、借用检查器</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="习语"><a class="header" href="#习语">习语</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Programming_idiom">习语</a>是常用的风格和模式，主要由一个社区商定。它们是准则。
编写习惯性代码可以让其他开发者了解正在发生的事情，因为他们熟悉它的形式。</p>
<p>计算机能够理解由编译器生成的机器代码。
因此，编程语言大多对开发者有利。
所以，既然我们有这个抽象层，为什么不好好利用它，让它变得简单？</p>
<p>记住<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS原则</a>：
&quot;保持简单，愚蠢&quot;。&quot;大多数系统如果保持简单而不是变得复杂，那么它们的工作效果最好；因此，简单应该是设计的一个关键目标，应该避免不必要的复杂性&quot;。</p>
<blockquote>
<p>代码是给人看的，而不是给电脑看的。</p>
</blockquote>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用借用类型作为参数"><a class="header" href="#使用借用类型作为参数">使用借用类型作为参数</a></h1>
<h2 id="描述"><a class="header" href="#描述">描述</a></h2>
<p>当你决定为一个函数参数使用哪种参数类型时，使用解引用强制转换的目标可以增加你代码的灵活性。
通过这种方式，该函数将接受更多的输入类型。</p>
<p>这并不限于可切片或胖指针类型。
事实上，你应该总是倾向于使用<strong>借用类型</strong>而不是<strong>借用所有类型</strong>。
例如<code>&amp;str</code>而不是<code>&amp;String</code>，<code>&amp;[T]</code>而不是<code>&amp;Vec&lt;T&gt;</code>，以及<code>&amp;T</code>而不是<code>&amp;Box&lt;T&gt;</code>。</p>
<p>使用借用类型，你可以避免已经提供一层间接性的所有类型上的多层间接。例如，<code>String</code>有一层间接，所以<code>&amp;String</code>会有两层间接。我们可以通过使用<code>&amp;str</code>来避免这种情况，并且让<code>&amp;String</code>在函数被调用时强制变成<code>&amp;str</code>。</p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<p>在这个例子中，我们将说明使用<code>&amp;String</code>作为函数参数与使用<code>&amp;str</code>的一些区别，但这些想法也适用于使用<code>&amp;Vec&lt;T&gt;</code>与使用<code>&amp;[T]</code>或使用<code>&amp;Box&lt;T&gt;</code>与使用<code>&amp;T</code>。</p>
<p>考虑这样一个例子，我们希望确定一个词是否包含三个连续的元音。我们不需要拥有字符串来确定这一点，所以我们将使用一个引用。</p>
<p>代码可能看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let ferris = &quot;Ferris&quot;.to_string();
    let curious = &quot;Curious&quot;.to_string();
    println!(&quot;{}: {}&quot;, ferris, three_vowels(&amp;ferris));
    println!(&quot;{}: {}&quot;, curious, three_vowels(&amp;curious));

    // This works fine, but the following two lines would fail:
    // println!(&quot;Ferris: {}&quot;, three_vowels(&quot;Ferris&quot;));
    // println!(&quot;Curious: {}&quot;, three_vowels(&quot;Curious&quot;));

}
</code></pre></pre>
<p>这样做没问题，因为我们传递的是一个<code>&amp;String</code>类型作为参数。
如果我们在最后两行取消注释，这个例子就会失败，因为<code>&amp;str</code>类型不会被强制变成<code>&amp;String</code>类型。我们可以通过简单地修改参数的类型来解决这个问题。</p>
<p>例如，如果我们把我们的函数声明改成：</p>
<pre><code class="language-rust  ignore">fn three_vowels(word: &amp;str) -&gt; bool {
</code></pre>
<p>那么这两个版本都会编译并打印相同的输出。</p>
<pre><code class="language-bash">Ferris: false
Curious: true
</code></pre>
<p>但等等，这还不是全部！这个话题还有更多的内容。
很可能你会对自己说：这并不重要，无论如何我都不会使用<code>&amp;'static str</code>作为输入（就像我们使用<code>&quot;Ferris&quot;</code>时那样）。
即使忽略这个特殊的例子，你仍然会发现使用<code>&amp;str</code>会比使用<code>&amp;String</code>更灵活。</p>
<p>现在我们来举个例子，有人给了我们一个句子，我们想确定句子中的任何一个词是否包含三个连续的元音。我们也许应该利用我们已经定义的函数，简单地输入句子中的每个词。</p>
<p>这个例子可能是这样的:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<p>使用我们声明的参数类型为<code>&amp;str</code>的函数运行这个例子将产生如下结果</p>
<pre><code class="language-bash">curious has three consecutive vowels!
</code></pre>
<p>然而，当我们的函数以参数类型<code>&amp;String</code>声明时，这个例子将无法运行。这是因为字符串切片是一个<code>&amp;str</code>，而不是一个<code>&amp;String</code>，后者需要一次内存分配来转换为<code>&amp;String</code>，这不是隐式的，而从<code>String</code>转换为<code>&amp;str</code>开销很低，而且是隐式的。</p>
<h2 id="参见"><a class="header" href="#参见">参见</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-coercions.html">Rust语言参考中关于类型强制转换</a></li>
<li>关于如何处理<code>String</code>和<code>&amp;str</code>的更多讨论见
<a href="https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html">blog系列（2015）</a>
by Herman J. Radtke III</li>
</ul>
<blockquote>
<p>Latest commit dca0dfd on Dec 16 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concatenating-strings-with-format"><a class="header" href="#concatenating-strings-with-format">Concatenating strings with <code>format!</code></a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>It is possible to build up strings using the <code>push</code> and <code>push_str</code> methods on a
mutable <code>String</code>, or using its <code>+</code> operator. However, it is often more
convenient to use <code>format!</code>, especially where there is a mix of literal and
non-literal strings.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hello(name: &amp;str) -&gt; String {
    // We could construct the result string manually.
    // let mut result = &quot;Hello &quot;.to_owned();
    // result.push_str(name);
    // result.push('!');
    // result

    // But using format! is better.
    format!(&quot;Hello {}!&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<p>Using <code>format!</code> is usually the most succinct and readable way to combine strings.</p>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<p>It is usually not the most efficient way to combine strings - a series of <code>push</code>
operations on a mutable string is usually the most efficient (especially if the
string has been pre-allocated to the expected size).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Rust does not have constructors as a language construct. Instead, the
convention is to use an <a href="https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html#associated-functions">associated function</a> <code>new</code> to create an object:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::new(42);
/// assert_eq!(42, s.value());
/// ```
pub struct Second {
    value: u64
}

impl Second {
    // Constructs a new instance of [`Second`].
    // Note this is an associated function - no self.
    pub fn new(value: u64) -&gt; Self {
        Self { value }
    }

    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="default-constructors"><a class="header" href="#default-constructors">Default Constructors</a></h2>
<p>Rust supports default constructors with the <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
pub struct Second {
    value: u64
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}

impl Default for Second {
    fn default() -&gt; Self {
        Self { value: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Default</code> can also be derived if all types of all fields implement <code>Default</code>,
like they do with <code>Second</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
#[derive(Default)]
pub struct Second {
    value: u64
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> When implementing <code>Default</code> for a type, it is neither required nor
recommended to also provide an associated function <code>new</code> without arguments.</p>
<p><strong>Hint:</strong> The advantage of implementing or deriving <code>Default</code> is that your type
can now be used where a <code>Default</code> implementation is required, most prominently,
any of the <a href="https://doc.rust-lang.org/stable/std/?search=or_default"><code>*or_default</code> functions in the standard library</a>.</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li>
<p>The <a href="idioms/default.html">default idiom</a> for a more in-depth description of the
<code>Default</code> trait.</p>
</li>
<li>
<p>The <a href="idioms/../patterns/creational/builder.html">builder pattern</a> for constructing
objects where there are multiple configurations.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-default-trait"><a class="header" href="#the-default-trait">The <code>Default</code> Trait</a></h1>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Many types in Rust have a <a href="idioms/ctor.html">constructor</a>. However, this is <em>specific</em> to the
type; Rust cannot abstract over &quot;everything that has a <code>new()</code> method&quot;. To
allow this, the <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> trait was conceived, which can be used with
containers and other generic types (e.g. see <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a>).
Notably, some containers already implement it where applicable.</p>
<p>Not only do one-element containers like <code>Cow</code>, <code>Box</code> or <code>Arc</code> implement
<code>Default</code> for contained <code>Default</code> types, one can automatically
<code>#[derive(Default)]</code> for structs whose fields all implement it, so the more
types implement <code>Default</code>, the more useful it becomes.</p>
<p>On the other hand, constructors can take multiple arguments, while the
<code>default()</code> method does not. There can even be multiple constructors with
different names, but there can only be one <code>Default</code> implementation per type.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.
#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
        
    // partial initialization with default values, creates the same instance
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}
</code></pre></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li>The <a href="idioms/ctor.html">constructor</a> idiom is another way to generate instances that may or may
not be &quot;default&quot;</li>
<li>The <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> documentation (scroll down for the list of implementors)</li>
<li><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a></li>
<li><a href="https://crates.io/crates/derive-new/"><code>derive(new)</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections-are-smart-pointers"><a class="header" href="#collections-are-smart-pointers">Collections are smart pointers</a></h1>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>Use the <code>Deref</code> trait to treat collections like smart pointers, offering owning
and borrowed views of data.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Vec&lt;T&gt; {
    data: RawVec&lt;T&gt;,
    //..
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        //..
    }
}
</code></pre>
<p>A <code>Vec&lt;T&gt;</code> is an owning collection of <code>T</code>s, a slice (<code>&amp;[T]</code>) is a borrowed
collection of <code>T</code>s. Implementing <code>Deref</code> for <code>Vec</code> allows implicit dereferencing
from <code>&amp;Vec&lt;T&gt;</code> to <code>&amp;[T]</code> and includes the relationship in auto-derefencing
searches. Most methods you might expect to be implemented for <code>Vec</code>s are instead
implemented for slices.</p>
<p>See also <code>String</code> and <code>&amp;str</code>.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Ownership and borrowing are key aspects of the Rust language. Data structures
must account for these semantics properly in order to give a good user
experience. When implementing a data structure which owns its data, offering a
borrowed view of that data allows for more flexible APIs.</p>
<h2 id="advantages-1"><a class="header" href="#advantages-1">Advantages</a></h2>
<p>Most methods can be implemented only for the borrowed view, they are then
implicitly available for the owning view.</p>
<p>Gives clients a choice between borrowing or taking ownership of data.</p>
<h2 id="disadvantages-1"><a class="header" href="#disadvantages-1">Disadvantages</a></h2>
<p>Methods and traits only available via dereferencing are not taken into account
when bounds checking, so generic programming with data structures using this
pattern can get complex (see the <code>Borrow</code> and <code>AsRef</code> traits, etc.).</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Smart pointers and collections are analogous: a smart pointer points to a single
object, whereas a collection points to many objects. From the point of view of
the type system there is little difference between the two. A collection owns
its data if the only way to access each datum is via the collection and the
collection is responsible for deleting the data (even in cases of shared
ownership, some kind of borrowed view may be appropriate). If a collection owns
its data, it is usually useful to provide a view of the data as borrowed so that
it can be referenced multiple times.</p>
<p>Most smart pointers (e.g., <code>Foo&lt;T&gt;</code>) implement <code>Deref&lt;Target=T&gt;</code>. However,
collections will usually dereference to a custom type. <code>[T]</code> and <code>str</code> have some
language support, but in the general case, this is not necessary. <code>Foo&lt;T&gt;</code> can
implement <code>Deref&lt;Target=Bar&lt;T&gt;&gt;</code> where <code>Bar</code> is a dynamically sized type and
<code>&amp;Bar&lt;T&gt;</code> is a borrowed view of the data in <code>Foo&lt;T&gt;</code>.</p>
<p>Commonly, ordered collections will implement <code>Index</code> for <code>Range</code>s to provide
slicing syntax. The target will be the borrowed view.</p>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<p><a href="idioms/../anti_patterns/deref.html">Deref polymorphism anti-pattern</a>.</p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Documentation for <code>Deref</code> trait</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalisation-in-destructors"><a class="header" href="#finalisation-in-destructors">Finalisation in destructors</a></h1>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>Rust does not provide the equivalent to <code>finally</code> blocks - code that will be
executed no matter how a function is exited. Instead, an object's destructor can
be used to run code that must be run before exit.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-rust ignore">fn bar() -&gt; Result&lt;(), ()&gt; {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&amp;mut self) {
            println!(&quot;exit&quot;);
        }
    }

    // The dtor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}
</code></pre>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>If a function has multiple return points, then executing code on exit becomes
difficult and repetitive (and thus bug-prone). This is especially the case where
return is implicit due to a macro. A common case is the <code>?</code> operator which
returns if the result is an <code>Err</code>, but continues if it is <code>Ok</code>. <code>?</code> is used as
an exception handling mechanism, but unlike Java (which has <code>finally</code>), there is
no way to schedule code to run in both the normal and exceptional cases.
Panicking will also exit a function early.</p>
<h2 id="advantages-2"><a class="header" href="#advantages-2">Advantages</a></h2>
<p>Code in destructors will (nearly) be always run - copes with panics, early
returns, etc.</p>
<h2 id="disadvantages-2"><a class="header" href="#disadvantages-2">Disadvantages</a></h2>
<p>It is not guaranteed that destructors will run. For example, if there is an
infinite loop in a function or if running a function crashes before exit.
Destructors are also not run in the case of a panic in an already panicking
thread. Therefore, destructors cannot be relied on as finalizers where it is
absolutely essential that finalisation happens.</p>
<p>This pattern introduces some hard to notice, implicit code. Reading a function
gives no clear indication of destructors to be run on exit. This can make
debugging tricky.</p>
<p>Requiring an object and <code>Drop</code> impl just for finalisation is heavy on boilerplate.</p>
<h2 id="discussion-1"><a class="header" href="#discussion-1">Discussion</a></h2>
<p>There is some subtlety about how exactly to store the object used as a
finalizer. It must be kept alive until the end of the function and must then be
destroyed. The object must always be a value or uniquely owned pointer (e.g.,
<code>Box&lt;Foo&gt;</code>). If a shared pointer (such as <code>Rc</code>) is used, then the finalizer can
be kept alive beyond the lifetime of the function. For similar reasons, the
finalizer should not be moved or returned.</p>
<p>The finalizer must be assigned into a variable, otherwise it will be destroyed
immediately, rather than when it goes out of scope. The variable name must start
with <code>_</code> if the variable is only used as a finalizer, otherwise the compiler
will warn that the finalizer is never used. However, do not call the variable
<code>_</code> with no suffix - in that case it will be destroyed immediately.</p>
<p>In Rust, destructors are run when an object goes out of scope. This happens
whether we reach the end of block, there is an early return, or the program
panics. When panicking, Rust unwinds the stack running destructors for each
object in each stack frame. So, destructors get called even if the panic happens
in a function being called.</p>
<p>If a destructor panics while unwinding, there is no good action to take, so Rust
aborts the thread immediately, without running further destructors. This means
that destructors are not absolutely guaranteed to run. It also means that you
must take extra care in your destructors not to panic, since it could leave
resources in an unexpected state.</p>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<p><a href="idioms/../patterns/behavioural/RAII.html">RAII guards</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在发生改变的枚举中使用memtake_-replace_来保留所有值"><a class="header" href="#在发生改变的枚举中使用memtake_-replace_来保留所有值">在发生改变的枚举中使用<code>mem::{take(_), replace(_)}</code>来保留所有值</a></h1>
<h2 id="描述-1"><a class="header" href="#描述-1">描述</a></h2>
<p>假定我们有一个<code>&amp;mut MyEnum</code>，它有（至少）两个变体，
<code>A { name: String, x: u8 }</code>和<code>B { name: String }</code>。
现在我们想如果<code>x</code>为零，把<code>MyEnum::A</code>改成<code>B</code>，同时保持<code>MyEnum::B</code>不变。</p>
<p>我们可以在不克隆<code>name</code>的情况下做到这一点。</p>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String }
}

fn a_to_b(e: &amp;mut MyEnum) {
    if let MyEnum::A { name, x: 0 } = e {
        // this takes out our `name` and put in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`).
        *e = MyEnum::B { name: mem::take(name) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这也适用于更多的变体：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B { name: mem::take(name) },
        B { name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机"><a class="header" href="#动机">动机</a></h2>
<p>在处理枚举时，我们可能想在原地改变一个枚举值，也许是改变成另一个变体。 
为了通过借用检查器，这通常分两个阶段进行。
在第一阶段，我们观察现有值，看看它的各个部分，以决定下一步该做什么
在第二阶段，我们可以有条件地改变该值（如上面的例子）。</p>
<p>借用检查器不允许我们取走枚举类型的<code>name</code>（因为<em>something</em>必须存在。）
尽管我们可以<code>.clone()``name</code>然后将克隆值放入<code>MyEnum::B</code>中，但这就是反面模式<a href="idioms/../anti_patterns/borrow_clone.html">通过Clone来满足借用检查器</a> 的一个例子了。 
无论如何，我们可以通过只用一个可变借用来改变<code>e</code>，进而避免额外的内存分配。</p>
<p><code>mem::take</code>可以换掉这个值，用它的默认值代替，并返回之前的值。
对于<code>String</code>，默认值是一个空的<code>String</code>，不需要分配内存。
最终，我们得到了原来的<code>name</code><em>作为一个所有值</em>。然后我们可以把它包在另一个枚举中。</p>
<p><strong>注意：</strong> <code>mem::replace</code>非常相似，但允许我们指定用什么来替换值。
<code>mem::take</code>等价于<code>mem::replace(name, String::new())</code>.</p>
<p>但是请注意，如果我们使用一个<code>Option</code>，并想用一个<code>None</code>来替换它的值，<code>Option</code>的<code>take()</code>方法提供了一个更短和更习惯的替代方法。</p>
<h2 id="优势"><a class="header" href="#优势">优势</a></h2>
<p>没有内存分配。</p>
<h2 id="劣势"><a class="header" href="#劣势">劣势</a></h2>
<p>表达比较啰嗦，经常搞错会让你讨厌借用检查器。 
编译器可能无法优化掉双重存储，从而导致性能下降，这与你在不安全语言中的做法是不同的。</p>
<p>此外，你拿走的类型需要实现<a href="idioms/./default.html"><code>Default</code>trait</a>。 
如果你正在使用的类型没有实现，你可以使用<code>mem::replace</code>代替。</p>
<h2 id="讨论"><a class="header" href="#讨论">讨论</a></h2>
<p>这种模式只在Rust中才有意义。
在有垃圾回收的语言中，默认取值的引用（GC会跟踪引用），而在其他低级语言如C语言中，可以简单地别名指针，并在以后修复。</p>
<p>然而，在Rust中，我们必须多做一点工作才能做到这一点。一个所有值可能只有一个所有者，所以要把它取出来，我们需要把一些东西放回去。</p>
<h2 id="参见-1"><a class="header" href="#参见-1">参见</a></h2>
<p>在特定情况下，可以去除<a href="idioms/../anti_patterns/borrow_clone.html">通过Clone来满足借用检查器</a>的反面模式。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-stack-dynamic-dispatch"><a class="header" href="#on-stack-dynamic-dispatch">On-Stack Dynamic Dispatch</a></h1>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>We can dynamically dispatch over multiple values, however, to do so, we need
to declare multiple variables to bind differently-typed objects. To extend the
lifetime as necessary, we can use deferred conditional initialization, as seen
below:</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::io;
use std::fs;

<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">let arg = &quot;-&quot;;
</span>
// These must live longer than `readable`, and thus are declared first:
let (mut stdin_read, mut file_read);

// We need to ascribe the type to get dynamic dispatch.
let readable: &amp;mut dyn io::Read = if arg == &quot;-&quot; {
    stdin_read = io::stdin();
    &amp;mut stdin_read
} else {
    file_read = fs::File::open(arg)?;
    &amp;mut file_read
};

// Read from `readable` here.

<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>Rust monomorphises code by default. This means a copy of the code will be
generated for each type it is used with and optimized independently. While this
allows for very fast code on the hot path, it also bloats the code in places
where performance is not of the essence, thus costing compile time and cache
usage.</p>
<p>Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly ask
for it.</p>
<h2 id="advantages-3"><a class="header" href="#advantages-3">Advantages</a></h2>
<p>We do not need to allocate anything on the heap. Neither do we need to
initialize something we won't use later, nor do we need to monomorphize the
whole code that follows to work with both <code>File</code> or <code>Stdin</code>.</p>
<h2 id="disadvantages-3"><a class="header" href="#disadvantages-3">Disadvantages</a></h2>
<p>The code needs more moving parts than the <code>Box</code>-based version:</p>
<pre><code class="language-rust ignore">// We still need to ascribe the type for dynamic dispatch.
let readable: Box&lt;dyn io::Read&gt; = if arg == &quot;-&quot; {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// Read from `readable` here.
</code></pre>
<h2 id="discussion-2"><a class="header" href="#discussion-2">Discussion</a></h2>
<p>Rust newcomers will usually learn that Rust requires all variables to be
initialized <em>before use</em>, so it's easy to overlook the fact that <em>unused</em>
variables may well be uninitialized. Rust works quite hard to ensure that this
works out fine and only the initialized values are dropped at the end of their
scope.</p>
<p>The example meets all the constraints Rust places on us:</p>
<ul>
<li>All variables are initialized before using (in this case borrowing) them</li>
<li>Each variable only holds values of a single type. In our example, <code>stdin</code> is
of type <code>Stdin</code>, <code>file</code> is of type <code>File</code> and <code>readable</code> is of type <code>&amp;mut dyn Read</code></li>
<li>Each borrowed value outlives all the references borrowed from it</li>
</ul>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<ul>
<li><a href="idioms/dtor-finally.html">Finalisation in destructors</a> and
<a href="idioms/../patterns/behavioural/RAII.html">RAII guards</a> can benefit from tight control over
lifetimes.</li>
<li>For conditionally filled <code>Option&lt;&amp;T&gt;</code>s of (mutable) references, one can
initialize an <code>Option&lt;T&gt;</code> directly and use its <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref"><code>.as_ref()</code></a> method to get an
optional reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-idioms"><a class="header" href="#ffi-idioms">FFI Idioms</a></h1>
<p>Writing FFI code is an entire course in itself.
However, there are several idioms here that can act as pointers, and avoid
traps for inexperienced users of <code>unsafe</code> Rust.</p>
<p>This section contains idioms that may be useful when doing FFI.</p>
<ol>
<li>
<p><a href="idioms/ffi/./errors.html">Idiomatic Errors</a> - Error handling with integer codes and
sentinel return values (such as <code>NULL</code> pointers)</p>
</li>
<li>
<p><a href="idioms/ffi/./accepting-strings.html">Accepting Strings</a> with minimal unsafe code</p>
</li>
<li>
<p><a href="idioms/ffi/./passing-strings.html">Passing Strings</a> to FFI functions</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-in-ffi"><a class="header" href="#error-handling-in-ffi">Error Handling in FFI</a></h1>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>In foreign languages like C, errors are represented by return codes.
However, Rust's type system allows much more rich error information to be
captured a propogated through a full type.</p>
<p>This best practice shows different kinds of error codes, and how to expose them
in a usable way:</p>
<ol>
<li>Flat Enums should be converted to integers and returned as codes.</li>
<li>Structured Enums should be converted to an integer code with a string error
message for detail.</li>
<li>Custom Error Types should become &quot;transparent&quot;, with a C representation.</li>
</ol>
<h2 id="code-example"><a class="header" href="#code-example">Code Example</a></h2>
<h3 id="flat-enums"><a class="header" href="#flat-enums">Flat Enums</a></h3>
<pre><code class="language-rust ignore">enum DatabaseError {
    IsReadOnly = 1, // user attempted a write operation
    IOError = 2, // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}
</code></pre>
<h3 id="structured-enums"><a class="header" href="#structured-enums">Structured Enums</a></h3>
<pre><code class="language-rust ignore">pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;

    #[no_mangle]
    pub extern &quot;C&quot; fn db_error_description(
        e: *const DatabaseError
        ) -&gt; *mut libc::c_char {

        let error: &amp;DatabaseError = unsafe {
            // SAFETY: pointer lifetime is greater than the current stack frame
            &amp;*e
        };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!(&quot;cannot write to read-only database&quot;);
            }
            DatabaseError::IOError(e) =&gt; {
                format!(&quot;I/O Error: {}&quot;, e);
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!(&quot;File corrupted, run repair: {}&quot;, &amp;s);
            }
        };

        let c_error = unsafe {
            // SAFETY: copying error_str to an allocated buffer with a NUL
            // character at the end
            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as *mut _;

            if malloc.is_null() {
                return std::ptr::null_mut();
            }

            let src = error_str.as_bytes().as_ptr();

            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());

            std::ptr::write(malloc.add(error_str.len()), 0);

            malloc as *mut libc::c_char
        };

        c_error
    }
}
</code></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<pre><code class="language-rust ignore">struct ParseError {
    expected: char,
    line: u32,
    ch: u16
}

impl ParseError { /* ... */ }

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}
</code></pre>
<h2 id="advantages-4"><a class="header" href="#advantages-4">Advantages</a></h2>
<p>This ensures that the foreign language has clear access to error information
while not compromising the Rust code's API at all.</p>
<h2 id="disadvantages-4"><a class="header" href="#disadvantages-4">Disadvantages</a></h2>
<p>It's a lot of typing, and some types may not be able to be converted easily
to C.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accepting-strings"><a class="header" href="#accepting-strings">Accepting Strings</a></h1>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>When accepting strings via FFI through pointers, there are two principles that
should be followed:</p>
<ol>
<li>Keep foreign strings &quot;borrowed&quot;, rather than copying them directly.</li>
<li>Minimize the amount of complexity and <code>unsafe</code> code involved in converting
from a C-style string to native Rust strings.</li>
</ol>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>The strings used in C have different behaviours to those used in Rust, namely:</p>
<ul>
<li>C strings are null-terminated while Rust strings store their length</li>
<li>C strings can contain any arbitrary non-zero byte while Rust strings must be
UTF-8</li>
<li>C strings are accessed and manipulated using <code>unsafe</code> pointer operations
while interactions with Rust strings go through safe methods</li>
</ul>
<p>The Rust standard library comes with C equivalents of Rust's <code>String</code> and <code>&amp;str</code>
called <code>CString</code> and <code>&amp;CStr</code>, that allow us to avoid a lot of the complexity
and <code>unsafe</code> code involved in converting between C strings and Rust strings.</p>
<p>The <code>&amp;CStr</code> type also allows us to work with borrowed data, meaning passing
strings between Rust and C is a zero-cost operation.</p>
<h2 id="code-example-1"><a class="header" href="#code-example-1">Code Example</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    /// Log a message at the specified level.
    ///
    /// # Safety
    ///
    /// It is the caller's guarantee to ensure `msg`:
    ///
    /// - is not a null pointer
    /// - points to valid, initialized data
    /// - points to memory ending in a null byte
    /// - won't be mutated for the duration of this function call
    #[no_mangle]
    pub unsafe extern &quot;C&quot; fn mylib_log(
        msg: *const libc::c_char,
        level: libc::c_int
    ) {
        let level: crate::LogLevel = match level { /* ... */ };

        // SAFETY: The caller has already guaranteed this is okay (see the
        // `# Safety` section of the doc-comment).
        let msg_str: &amp;str = match std::ffi::CStr::from_ptr(msg).to_str() {
            Ok(s) =&gt; s,
            Err(e) =&gt; {
                crate::log_error(&quot;FFI string conversion failed&quot;);
                return;
            }
        };

        crate::log(msg_str, level);
    }
}
</code></pre>
<h2 id="advantages-5"><a class="header" href="#advantages-5">Advantages</a></h2>
<p>The example is is written to ensure that:</p>
<ol>
<li>The <code>unsafe</code> block is as small as possible.</li>
<li>The pointer with an &quot;untracked&quot; lifetime becomes a &quot;tracked&quot; shared
reference</li>
</ol>
<p>Consider an alternative, where the string is actually copied:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub extern &quot;C&quot; fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        // DO NOT USE THIS CODE.
        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.

        let level: crate::LogLevel = match level { /* ... */ };

        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */
            libc::strlen(msg)
        };

        let mut msg_data = Vec::with_capacity(msg_len + 1);

        let msg_cstr: std::ffi::CString = unsafe {
            // SAFETY: copying from a foreign pointer expected to live
            // for the entire stack frame into owned memory
            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);

            msg_data.set_len(msg_len + 1);

            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()
        }

        let msg_str: String = unsafe {
            match msg_cstr.into_string() {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    crate::log_error(&quot;FFI string conversion failed&quot;);
                    return;
                }
            }
        };

        crate::log(&amp;msg_str, level);
    }
}
</code></pre>
<p>This code in inferior to the original in two respects:</p>
<ol>
<li>There is much more <code>unsafe</code> code, and more importantly, more invariants it
must uphold.</li>
<li>Due to the extensive arithmetic required, there is a bug in this version
that cases Rust <code>undefined behaviour</code>.</li>
</ol>
<p>The bug here is a simple mistake in pointer arithmetic: the string was copied,
all <code>msg_len</code> bytes of it. However, the <code>NUL</code> terminator at the end was not.</p>
<p>The Vector then had its size <em>set</em> to the length of the <em>zero padded string</em> --
rather than <em>resized</em> to it, which could have added a zero at the end.
As a result, the last byte in the Vector is uninitialized memory.
When the <code>CString</code> is created at the bottom of the block, its read of the
Vector will cause <code>undefined behaviour</code>!</p>
<p>Like many such issues, this would be difficult issue to track down.
Sometimes it would panic because the string was not <code>UTF-8</code>, sometimes it would
put a weird character at the end of the string, sometimes it would just
completely crash.</p>
<h2 id="disadvantages-5"><a class="header" href="#disadvantages-5">Disadvantages</a></h2>
<p>None?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-strings"><a class="header" href="#passing-strings">Passing Strings</a></h1>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<p>When passing strings to FFI functions, there are four principles that should be
followed:</p>
<ol>
<li>Make the lifetime of owned strings as long as possible.</li>
<li>Minimize <code>unsafe</code> code during the conversion.</li>
<li>If the C code can modify the string data, use <code>Vec</code> instead of <code>CString</code>.</li>
<li>Unless the Foreign Function API requires it, the ownership of the string
should not transfer to the callee.</li>
</ol>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p>Rust has built-in support for C-style strings with its <code>CString</code> and <code>CStr</code>
types. However, there are different approaches one can take with strings that
are being sent to a foreign function call from a Rust function.</p>
<p>The best practice is simple: use <code>CString</code> in such a way as to minimize
<code>unsafe</code> code. However, a secondary caveat is that
<em>the object must live long enough</em>, meaning the lifetime should be maximized.
In addition, the documentation explains that &quot;round-tripping&quot; a <code>CString</code> after
modification is UB, so additional work is necessary in that case.</p>
<h2 id="code-example-2"><a class="header" href="#code-example-2">Code Example</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    extern &quot;C&quot; {
        fn seterr(message: *const libc::c_char);
        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -&gt; libc::c_int;
    }

    fn report_error_to_ffi&lt;S: Into&lt;String&gt;&gt;(
        err: S
    ) -&gt; Result&lt;(), std::ffi::NulError&gt;{
        let c_err = std::ffi::CString::new(err.into())?;

        unsafe {
            // SAFETY: calling an FFI whose documentation says the pointer is
            // const, so no modification should occur
            seterr(c_err.as_ptr());
        }

        Ok(())
        // The lifetime of c_err continues until here
    }

    fn get_error_from_ffi() -&gt; Result&lt;String, std::ffi::IntoStringError&gt; {
        let mut buffer = vec![0u8; 1024];
        unsafe {
            // SAFETY: calling an FFI whose documentation implies
            // that the input need only live as long as the call
            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();

            buffer.truncate(written + 1);
        }

        std::ffi::CString::new(buffer).unwrap().into_string()
    }
}
</code></pre>
<h2 id="advantages-6"><a class="header" href="#advantages-6">Advantages</a></h2>
<p>The example is written in a way to ensure that:</p>
<ol>
<li>The <code>unsafe</code> block is as small as possible.</li>
<li>The <code>CString</code> lives long enough.</li>
<li>Errors with typecasts are always propagated when possible.</li>
</ol>
<p>A common mistake (so common it's in the documentation) is to not use the
variable in the first block:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    fn report_error&lt;S: Into&lt;String&gt;&gt;(err: S) -&gt; Result&lt;(), std::ffi::NulError&gt; {
        unsafe {
            // SAFETY: whoops, this contains a dangling pointer!
            seterr(std::ffi::CString::new(err.into())?.as_ptr());
        }
        Ok(())
    }
}
</code></pre>
<p>This code will result in a dangling pointer, because the lifetime of the
<code>CString</code> is not extended by the pointer creation, unlike if a reference were
created.</p>
<p>Another issue frequently raised is that the initialization of a 1k vector of
zeroes is &quot;slow&quot;. However, recent versions of Rust actually optimize that
particular macro to a call to <code>zmalloc</code>, meaning it is as fast as the operating
system's ability to return zeroed memory (which is quite fast).</p>
<h2 id="disadvantages-6"><a class="header" href="#disadvantages-6">Disadvantages</a></h2>
<p>None?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterating-over-an-option"><a class="header" href="#iterating-over-an-option">Iterating over an <code>Option</code></a></h1>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<p><code>Option</code> can be viewed as a container that contains either zero or one
element. In particular, it implements the <code>IntoIterator</code> trait, and as such
can be used with generic code that needs such a type.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Since <code>Option</code> implements <code>IntoIterator</code>, it can be used as an argument to
<a href="https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend"><code>.extend()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let mut logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

logicians.extend(turing);

// equivalent to
if let Some(turing_inner) = turing {
    logicians.push(turing_inner);
}
<span class="boring">}
</span></code></pre></pre>
<p>If you need to tack an <code>Option</code> to the end of an existing iterator, you can
pass it to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

for logician in logicians.iter().chain(turing.iter()) {
    println!(&quot;{} is a logician&quot;, logician);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that if the <code>Option</code> is always <code>Some</code>, then it is more idiomatic to use
<a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> on the
element instead.</p>
<p>Also, since <code>Option</code> implements <code>IntoIterator</code>, it's possible to iterate over
it using a <code>for</code> loop. This is equivalent to matching it with <code>if let Some(..)</code>,
and in most cases you should prefer the latter.</p>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See also</a></h2>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> is an
iterator which yields exactly one element. It's a more readable alternative to
<code>Some(foo).into_iter()</code>.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"><code>Iterator::filter_map</code></a>
is a version of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>Iterator::flat_map</code></a>,
specialized to mapping functions which return <code>Option</code>.</p>
</li>
<li>
<p>The <a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> crate provides functions
for converting an <code>Option</code> to a zero- or one-element slice.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Documentation for <code>Option&lt;T&gt;</code></a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-variables-to-closure"><a class="header" href="#pass-variables-to-closure">Pass variables to closure</a></h1>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<p>By default, closures capture their environment by borrowing. Or you can use
<code>move</code>-closure to move whole environment. However, often you want to move just
some variables to closure, give it copy of some data, pass it by reference, or
perform some other transformation.</p>
<p>Use variable rebinding in separate scope for that.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<p>Use</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>instead of</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="advantages-7"><a class="header" href="#advantages-7">Advantages</a></h2>
<p>Copied data are grouped together with closure definition, so their purpose is
more clear, and they will be dropped immediately even if they are not consumed
by closure.</p>
<p>Closure uses same variable names as surrounding code whether data are copied or
moved.</p>
<h2 id="disadvantages-7"><a class="header" href="#disadvantages-7">Disadvantages</a></h2>
<p>Additional indentation of closure body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non_exhaustive-and-private-fields-for-extensibility"><a class="header" href="#non_exhaustive-and-private-fields-for-extensibility"><code>#[non_exhaustive]</code> and private fields for extensibility</a></h1>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<p>A small set of scenarios exist where a library author may want to add public
fields to a public struct or new variants to an enum without breaking backwards
compatibility.</p>
<p>Rust offers two solutions to this problem:</p>
<ul>
<li>
<p>Use <code>#[non_exhaustive]</code> on <code>struct</code>s, <code>enum</code>s, and <code>enum</code> variants.
For extensive documentation on all the places where <code>#[non_exhaustive]</code> can be
used, see <a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute">the docs</a>.</p>
</li>
<li>
<p>You may add a private field to a struct to prevent it from being directly
instantiated or matched against (see Alternative)</p>
</li>
</ul>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    // Public struct.
    #[non_exhaustive]
    pub struct S {
        pub foo: i32,
    }
    
    #[non_exhaustive]
    pub enum AdmitMoreVariants {
        VariantA,
        VariantB,
        #[non_exhaustive]
        VariantC { a: String }
    }
}

fn print_matched_variants(s: a::S) {
    // Because S is `#[non_exhaustive]`, it cannot be named here and
    // we must use `..` in the pattern.
    let a::S { foo: _, ..} = s;
    
    let some_enum = a::AdmitMoreVariants::VariantA;
    match some_enum {
        a::AdmitMoreVariants::VariantA =&gt; println!(&quot;it's an A&quot;),
        a::AdmitMoreVariants::VariantB =&gt; println!(&quot;it's a b&quot;),

        // .. required because this variant is non-exhaustive as well
        a::AdmitMoreVariants::VariantC { a, .. } =&gt; println!(&quot;it's a c&quot;),

        // The wildcard match is required because more variants may be
        // added in the future
        _ =&gt; println!(&quot;it's a new variant&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="alternative-private-fields-for-structs"><a class="header" href="#alternative-private-fields-for-structs">Alternative: <code>Private fields</code> for structs</a></h2>
<p><code>#[non_exhaustive]</code> only works across crate boundaries.
Within a crate, the private field method may be used.</p>
<p>Adding a field to a struct is a mostly backwards compatible change.
However, if a client uses a pattern to deconstruct a struct instance, they
might name all the fields in the struct and adding a new one would break that
pattern.
The client could name some fields and use <code>..</code> in the pattern, in which case adding
another field is backwards compatible.
Making at least one of the struct's fields private forces clients to use the latter
form of patterns, ensuring that the struct is future-proof.</p>
<p>The downside of this approach is that you might need to add an otherwise unneeded
field to the struct.
You can use the <code>()</code> type so that there is no runtime overhead and prepend <code>_</code> to
the field name to avoid the unused field warning.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    pub a: i32,
    // Because `b` is private, you cannot match on `S` without using `..` and `S`
    //  cannot be directly instantiated or matched against
    _b: ()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="discussion-3"><a class="header" href="#discussion-3">Discussion</a></h2>
<p>On <code>struct</code>s, <code>#[non_exhaustive]</code> allows adding additional fields in a backwards
compatible way.
It will also prevent clients from using the struct constructor, even if all the
fields are public.
This may be helpful, but it's worth considering if you <em>want</em> an additional field
to be found by clients as a compiler error rather than something that may be silently
undiscovered.</p>
<p><code>#[non_exhaustive]</code> can be applied to enum variants as well.
A <code>#[non_exhaustive]</code> variant behaves in the same way as a <code>#[non_exhaustive]</code> struct.</p>
<p>Use this deliberately and with caution: incrementing the major version when adding
fields or variants is often a better option.
<code>#[non_exhaustive]</code> may be appropriate in scenarios where you're modeling an external
resource that may change out-of-sync with your library, but is not a general purpose
tool.</p>
<h3 id="disadvantages-8"><a class="header" href="#disadvantages-8">Disadvantages</a></h3>
<p><code>#[non_exhaustive]</code> can make your code much less ergonomic to use, especially when
forced to handle unknown enum variants.
It should only be used when these sorts of evolutions are required <strong>without</strong>
incrementing the major version.</p>
<p>When <code>#[non_exhaustive]</code> is applied to <code>enum</code>s, it forces clients to handle a
wildcard variant.
If there is no sensible action to take in this case, this may lead to awkward
code and code paths that are only executed in extremely rare circumstances.
If a client decides to <code>panic!()</code> in this scenario, it may have been better to
expose this error at compile time.
In fact, <code>#[non_exhaustive]</code> forces clients to handle the &quot;Something else&quot; case;
there is rarely a sensible action to take in this scenario.</p>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md">RFC introducing #[non_exhaustive] attribute for enums and structs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="easy-doc-initialization"><a class="header" href="#easy-doc-initialization">Easy doc initialization</a></h1>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<p>If a struct takes significant effort to initialize, when writing docs, it can be
quicker to wrap your example with a helper function which takes the struct as an
argument.</p>
<h2 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h2>
<p>Sometimes there is a struct with multiple or complicated parameters and several
methods. Each of these methods should have examples.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```no_run
    /// # // Boilerplate are required to get an example working.
    /// # let stream = TcpStream::connect(&quot;127.0.0.1:34254&quot;);
    /// # let connection = Connection { name: &quot;foo&quot;.to_owned(), stream };
    /// # let request = Request::new(&quot;RequestId&quot;, RequestType::Get, &quot;payload&quot;);
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// ```
    fn send_request(&amp;self, request: Request) -&gt; Result&lt;Status, SendErr&gt; {
        // ...
    }

    /// Oh no, all that boilerplate needs to be repeated here!
    fn check_status(&amp;self) -&gt; Status {
        // ...
    }
}
</code></pre>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>Instead of typing all of this boilerplate to create an <code>Connection</code> and
<code>Request</code> it is easier to just create a wrapping helper function which takes
them as arguments:</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```
    /// # fn call_send(connection: Connection, request: Request) {
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// # }
    /// ```
    fn send_request(&amp;self, request: Request) {
        // ...
    }
}
</code></pre>
<p><strong>Note</strong> in the above example the line <code>assert!(response.is_ok());</code> will not
actually run while testing because it is inside a function which is never
invoked.</p>
<h2 id="advantages-8"><a class="header" href="#advantages-8">Advantages</a></h2>
<p>This is much more concise and avoids repetitive code in examples.</p>
<h2 id="disadvantages-9"><a class="header" href="#disadvantages-9">Disadvantages</a></h2>
<p>As example is in a function, the code will not be tested. Though it will still be
checked to make sure it compiles when running a <code>cargo test</code>. So this pattern is
most useful when you need <code>no_run</code>. With this, you do not need to add <code>no_run</code>.</p>
<h2 id="discussion-4"><a class="header" href="#discussion-4">Discussion</a></h2>
<p>If assertions are not required this pattern works well.</p>
<p>If they are, an alternative can be to create a public method to create a helper
instance which is annotated with <code>#[doc(hidden)]</code> (so that users won't see it).
Then this method can be called inside of rustdoc because it is part of the
crate's public API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temporary-mutability"><a class="header" href="#temporary-mutability">Temporary mutability</a></h1>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<p>Often it is necessary to prepare and process some data, but after that data are
only inspected and never modified. The intention can be made explicit by redefining
the mutable variable as immutable.</p>
<p>It can be done either by processing data within nested block or by redefining
variable.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p>Say, vector must be sorted before usage.</p>
<p>Using nested block:</p>
<pre><code class="language-rust ignore">let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.
</code></pre>
<p>Using variable rebinding:</p>
<pre><code class="language-rust ignore">let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.
</code></pre>
<h2 id="advantages-9"><a class="header" href="#advantages-9">Advantages</a></h2>
<p>Compiler ensures that you don't accidentally mutate data after some point.</p>
<h2 id="disadvantages-10"><a class="header" href="#disadvantages-10">Disadvantages</a></h2>
<p>Nested block requires additional indentation of block body.
One more line to return data from block or redefine variable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Software_design_pattern">设计模式</a> 
是“在软件设计的特定背景下，对一个经常发生的问题的一般可重复使用的解决方案”。
设计模式是描述一种编程语言文化的好方法。
设计模式具有很强的语言特异性——在一种语言中属于模式的东西，在另一种语言中可能由于语言特性而不需要，或者由于缺少特性而无法表达。</p>
<p>如果过度使用，设计模式会给程序增加不必要的复杂性。
然而，它们是分享关于一种编程语言的中高级知识的好方法。</p>
<h2 id="rust中的设计模式-1"><a class="header" href="#rust中的设计模式-1">Rust中的设计模式</a></h2>
<p>Rust有许多特性。这些特性通过消除整类问题给我们带来了巨大的好处。其中有些也是Rust的<strong>独特</strong>模式。</p>
<h2 id="yagni"><a class="header" href="#yagni">YAGNI</a></h2>
<p>如果你不熟悉，YAGNI是一个缩写，代表<code>You Aren't Going to Need It</code>。这是一个重要的软件设计原则，在你写代码时要应用。</p>
<blockquote>
<p>我曾经写过的最好的代码是我从未写过的代码。</p>
</blockquote>
<p>如果我们将YAGNI应用于设计模式，我们会发现Rust的特性允许我们抛开许多模式。
例如，在Rust中没有必要使用<a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>因为我们有<a href="https://doc.rust-lang.org/book/traits.html">traits</a>。</p>
<p>TODO：加入一些代码来说明这些traits。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="行为型模式"><a class="header" href="#行为型模式">行为型模式</a></h1>
<p>来自<a href="https://en.wikipedia.org/wiki/Behavioral_pattern">Wikipedia</a>：</p>
<blockquote>
<p>识别对象间常见通信模式的设计模式。
这样做增加了进行通信的灵活性。</p>
</blockquote>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令"><a class="header" href="#命令">命令</a></h1>
<h2 id="描述-2"><a class="header" href="#描述-2">描述</a></h2>
<p>命令模式的基本思想是将行动分离成它自己的对象，并将它们作为参数传递。</p>
<h2 id="动机-1"><a class="header" href="#动机-1">动机</a></h2>
<p>假设我们有一连串的行动或事务被封装为对象。
我们希望这些行动或命令之后在不同的时间以某种顺序被执行或调用。
这些命令也可能因某些事件而被触发。
例如，当用户按下一个按钮，或在一个数据包到达时。
此外，这些命令可能是可撤销的。这可能对编辑器的操作很有用。 
我们可能想存储已执行命令的日志，这样，如果系统崩溃，我们可以之后重新应用这些变化。</p>
<h2 id="例子-2"><a class="header" href="#例子-2">例子</a></h2>
<p>定义两个数据库操作<code>create table</code>和<code>add field</code>。每一个操作都是一个可撤销的命令，例如，<code>drop table</code>和<code>remove field</code>。
当用户调用数据库迁移操作时，那么每条命令都按照定义的顺序执行，当用户调用回滚操作时，那么整个命令集将以相反的顺序调用。</p>
<h2 id="方法使用-trait-对象"><a class="header" href="#方法使用-trait-对象">方法：使用 trait 对象</a></h2>
<p>我们定义了一个共同的trait，用两个操作<code>execute</code>和<code>rollback</code>来封装我们的命令。所有的命令<code>structs</code>必须实现这个trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub trait Migration {
    fn execute(&amp;self) -&gt; &amp;str;
    fn rollback(&amp;self) -&gt; &amp;str;
}

pub struct CreateTable;
impl Migration for CreateTable {
    fn execute(&amp;self) -&gt; &amp;str {
        &quot;create table&quot;
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        &quot;drop table&quot;
    }
}

pub struct AddField;
impl Migration for AddField {
    fn execute(&amp;self) -&gt; &amp;str {
        &quot;add field&quot;
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        &quot;remove field&quot;
    }
}

struct Schema {
    commands: Vec&lt;Box&lt;dyn Migration&gt;&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }

    fn add_migration(&amp;mut self, cmd: Box&lt;dyn Migration&gt;) {
        self.commands.push(cmd);
    }

    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands.iter().map(|cmd| cmd.execute()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands
            .iter()
            .rev() // reverse iterator's direction
            .map(|cmd| cmd.rollback())
            .collect()
    }
}

fn main() {
    let mut schema = Schema::new();

    let cmd = Box::new(CreateTable);
    schema.add_migration(cmd);
    let cmd = Box::new(AddField);
    schema.add_migration(cmd);

    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="方法使用函数指针"><a class="header" href="#方法使用函数指针">方法：使用函数指针</a></h2>
<p>我们可以遵循另一种方法，将每个单独的命令创建为不同的函数，并存储函数指针，以便以后在不同的时间调用这些函数。
由于函数指针实现了所有三个trait <code>Fn</code>,<code>FnMut</code>和<code>FnOnce</code>，我们也可以传递和存储闭包而不是函数指针。</p>
<pre><pre class="playground"><code class="language-rust edition2018">type FnPtr = fn() -&gt; String;
struct Command {
    execute: FnPtr,
    rollback: FnPtr,
}

struct Schema {
    commands: Vec&lt;Command&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }
    fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) {
        self.commands.push(Command { execute, rollback });
    }
    fn execute(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands.iter().map(|cmd| (cmd.execute)()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands
            .iter()
            .rev()
            .map(|cmd| (cmd.rollback)())
            .collect()
    }
}

fn add_field() -&gt; String {
    &quot;add field&quot;.to_string()
}

fn remove_field() -&gt; String {
    &quot;remove field&quot;.to_string()
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| &quot;create table&quot;.to_string(), || &quot;drop table&quot;.to_string());
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="方法使用-fn-trait-对象"><a class="header" href="#方法使用-fn-trait-对象">方法：使用 <code>Fn</code> trait 对象</a></h2>
<p>最后，我们可以将实现<code>Fn</code>trait的每个命令分别存储在向量中，而不是定义一个共同的命令trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">type Migration&lt;'a&gt; = Box&lt;dyn Fn() -&gt; &amp;'a str&gt;;

struct Schema&lt;'a&gt; {
    executes: Vec&lt;Migration&lt;'a&gt;&gt;,
    rollbacks: Vec&lt;Migration&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; Schema&lt;'a&gt; {
    fn new() -&gt; Self {
        Self {
            executes: vec![],
            rollbacks: vec![],
        }
    }
    fn add_migration&lt;E, R&gt;(&amp;mut self, execute: E, rollback: R)
    where
        E: Fn() -&gt; &amp;'a str + 'static,
        R: Fn() -&gt; &amp;'a str + 'static,
    {
        self.executes.push(Box::new(execute));
        self.rollbacks.push(Box::new(rollback));
    }
    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.executes.iter().map(|cmd| cmd()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()
    }
}

fn add_field() -&gt; &amp;'static str {
    &quot;add field&quot;
}

fn remove_field() -&gt; &amp;'static str {
    &quot;remove field&quot;
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| &quot;create table&quot;, || &quot;drop table&quot;);
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="讨论-1"><a class="header" href="#讨论-1">讨论</a></h2>
<p>如果我们的命令很小，并且可以被定义为函数或者作为一个闭包传递，那么使用函数指针可能是更好的，因为它没有利用动态分发。 
但如果我们的命令是一个完整的结构体，其中有一堆函数和变量被定义为独立的模块，那么使用trait对象会更合适。
应用案例可以在<a href="https://actix.rs/"><code>actix</code></a>中找到，它在为路由注册处理函数时使用trait对象。
在使用<code>Fn</code>trait对象的情况下，我们可以用与函数指针相同的方式创建和使用命令。</p>
<p>关于性能，在性能和代码的简单性和组织性之间总是有一个权衡。
静态分发可以提供更快的性能，而动态分发在我们构造应用程序时提供了灵活性。</p>
<h2 id="参见-2"><a class="header" href="#参见-2">参见</a></h2>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Command_pattern">命令模式</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust">命令模式的另一个例子</a></p>
</li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解释器"><a class="header" href="#解释器">解释器</a></h1>
<h2 id="描述-3"><a class="header" href="#描述-3">描述</a></h2>
<p>如果一个问题经常发生，并且需要长时间重复的步骤来解决，那么问题实例可能用一种简单的语言来表达，一个解释器对象可以通过解释用这种简单语言写的句子来解决这个问题。</p>
<p>基本上，对于我们定义的任何种类的问题：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域特定语言</a>，</li>
<li>该语言的语法，</li>
<li>解决问题实例的解释器。</li>
</ul>
<h2 id="动机-2"><a class="header" href="#动机-2">动机</a></h2>
<p>我们的目标是将简单的数学表达式翻译成后缀表达式（或<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">逆波兰表示法</a>）
为了简单起见，我们的表达式由十个数字<code>0</code>，...，<code>9</code>和两个操作符<code>+</code>，<code>-</code>组成。例如，表达式<code>2 + 4</code>被翻译成<code>2 4 +</code>。</p>
<h2 id="有关我们问题的上下文无关文法"><a class="header" href="#有关我们问题的上下文无关文法">有关我们问题的上下文无关文法</a></h2>
<p>我们的任务是把中缀表达式翻译成后缀表达式。 
让我们为<code>0</code>, ..., <code>9</code>, <code>+</code>, 和<code>-</code>上的一组中缀表达式定义一个上下文无关文法，其中：</p>
<ul>
<li>终结符： <code>0</code>, ..., <code>9</code></li>
<li>非终结符： <code>exp</code>, <code>term</code>, <code>+</code>, <code>-</code></li>
<li>起始符是<code>exp</code></li>
<li>接下来是产生规则</li>
</ul>
<pre><code class="language-ignore">exp -&gt; exp + term
exp -&gt; exp - term
exp -&gt; term
term -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p><strong>注意：</strong> 这个文法应该根据我们要做的事情进行进一步的转化。例如，我们可能需要消除左递归。
详情请查阅<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Compilers: Principles,Techniques, and Tools</a>(aka Dragon Book).</p>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>我们简单地实现了一个递归下降分析器。为了简单起见，当一个表达式在语法上出错时（例如，根据语法定义，<code>2-34</code>或<code>2+5-</code>是错误的），代码会panic。</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub struct Interpreter&lt;'a&gt; {
    it: std::str::Chars&lt;'a&gt;,
}

impl&lt;'a&gt; Interpreter&lt;'a&gt; {

    pub fn new(infix: &amp;'a str) -&gt; Self {
        Self { it: infix.chars() }
    }

    fn next_char(&amp;mut self) -&gt; Option&lt;char&gt; {
        self.it.next()
    }

    pub fn interpret(&amp;mut self, out: &amp;mut String) {
        self.term(out);

        while let Some(op) = self.next_char() {
            if op == '+' || op == '-' {
                self.term(out);
                out.push(op);
            } else {
                panic!(&quot;Unexpected symbol '{}'&quot;, op);
            }
        }
    }

    fn term(&amp;mut self, out: &amp;mut String) {
        match self.next_char() {
            Some(ch) if ch.is_digit(10) =&gt; out.push(ch),
            Some(ch) =&gt; panic!(&quot;Unexpected symbol '{}'&quot;, ch),
            None =&gt; panic!(&quot;Unexpected end of string&quot;),
        }
    }
}

pub fn main() {
    let mut intr = Interpreter::new(&quot;2+3&quot;);
    let mut postfix = String::new();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;23+&quot;);

    intr = Interpreter::new(&quot;1-2+3-4&quot;);
    postfix.clear();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;12-3+4-&quot;);
}
</code></pre></pre>
<h2 id="讨论-2"><a class="header" href="#讨论-2">讨论</a></h2>
<p>可能有一种错误的看法，认为解释器设计模式是关于形式语言的文法设计和这些文法的分析器的实现。
事实上，这种模式是以一种更具体的方式来表达问题实例，并实现解决这些问题实例的函数/类/结构体。
Rust语言有<code>macro_rules!</code>，允许定义特殊的语法和如何将这种语法扩展到源代码的规则。</p>
<p>在下面的例子中，我们创建了一个简单的<code>macro_rules!</code>，计算<code>n</code>维向量的<a href="https://en.wikipedia.org/wiki/Euclidean_distance">欧几里得长度</a>。
写<code>norm!(x,1,2)</code>可能比把<code>x,1,2</code>打包成一个<code>Vec</code>并调用一个计算长度的函数更容易表达和更有效率。</p>
<pre><pre class="playground"><code class="language-rust edition2018">macro_rules! norm {
    ($($element:expr),*) =&gt; {
        {
            let mut n = 0.0;
            $(
                n += ($element as f64)*($element as f64);
            )*
            n.sqrt()
        }
    };
}

fn main() {
    let x = -3f64;
    let y = 4f64;

    assert_eq!(3f64, norm!(x));
    assert_eq!(5f64, norm!(x, y));
    assert_eq!(0f64, norm!(0, 0, 0)); 
    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));
}
</code></pre></pre>
<h2 id="参见-3"><a class="header" href="#参见-3">参见</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a></li>
<li>[上下文无关文法]](https://en.wikipedia.org/wiki/Context-free_grammar)</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro_rules!</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新类型"><a class="header" href="#新类型">新类型</a></h1>
<p>如果在某些情况下，我们希望一个类型的行为类似于另一个类型，或者在编译时强制执行一些行为，而仅仅使用类型别名是不够的，怎么办？</p>
<p>例如，如果我们出于安全考虑（如密码），想为<code>String</code>创建一个自定义的<code>Display</code>实现。</p>
<p>对于这种情况，我们可以使用<code>Newtype</code>模式来提供<strong>类型安全</strong>和<strong>封装</strong>。</p>
<h2 id="描述-4"><a class="header" href="#描述-4">描述</a></h2>
<p>使用单个字段的元组结构体为一个类型做不透明包装。
这将创建一个新的类型，而不是一个类型的别名（<code>type</code>项）。</p>
<h2 id="例子-3"><a class="header" href="#例子-3">例子</a></h2>
<pre><code class="language-rust ignore">// Some type, not necessarily in the same module or even crate.
struct Foo {
    //..
}

impl Foo {
    // These functions are not present on Bar.
    //..
}

// The newtype.
pub struct Bar(Foo);

impl Bar {
    // Constructor.
    pub fn new(
        //..
    ) -&gt; Self {

        //..

    }

    //..
}

fn main() {
    let b = Bar::new(...);

    // Foo and Bar are type incompatible, the following do not type check.
    // let f: Foo = b;
    // let b: Bar = Foo { ... };
}
</code></pre>
<h2 id="动机-3"><a class="header" href="#动机-3">动机</a></h2>
<p>新类型的主要动机是抽象化。它允许你在类型之间共享实现细节，同时精确控制接口。
通过使用新类型而不是将实现类型作为API的一部分公开，它允许你向后兼容地改变实现。</p>
<p>新类型可以用来区分单位，例如，包装<code>f64</code>以获得可区分的<code>Miles</code>和<code>Kms</code>。</p>
<h2 id="优势-1"><a class="header" href="#优势-1">优势</a></h2>
<p>被包装的类型和包装后的类型不是类型兼容的（相对于使用<code>type</code>），所以新类型的用户永远不会“混淆“包装前后的类型。</p>
<p>新类型是一个零成本的抽象——没有运行时的开销。</p>
<p>隐私系统确保用户无法访问被包装的类型（如果字段是私有的，默认情况下是私有的）。</p>
<h2 id="劣势-1"><a class="header" href="#劣势-1">劣势</a></h2>
<p>新类型的缺点（尤其是与类型别名相比）是没有特殊的语言支持。这意味着可能会有<em>许多</em>模板代码。
你需要为你想在包装类型上公开的每个方法提供一个”通过“方法，并为你想在包装类型上实现的每个trait提供一个实现。</p>
<h2 id="讨论-3"><a class="header" href="#讨论-3">讨论</a></h2>
<p>新类型在Rust代码中非常常见。抽象或代表单位是最常见的用途，但它们也可以用于其他原因：</p>
<ul>
<li>限制功能（减少暴露的函数或实现的trait），</li>
<li>使一个具有复制语义的类型具有移动语义，</li>
<li>通过提供一个更具体的类型，从而隐藏内部类型来实现抽象，
例如，</li>
</ul>
<pre><code class="language-rust ignore">pub struct Foo(Bar&lt;T1, T2&gt;);
</code></pre>
<p>这里，<code>Bar</code>可能是一些公共的、通用的类型，<code>T1</code>和<code>T2</code>是一些内部类型。
我们模块的用户不应该知道我们通过使用<code>Bar</code>来实现<code>Foo</code>，但我们在这里真正隐藏的是<code>T1</code>和<code>T2</code>类型，以及它们如何与<code>Bar</code>一起使用。</p>
<h2 id="参见-4"><a class="header" href="#参见-4">参见</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-abstraction">“圣经“中的高级类型</a></li>
<li><a href="https://wiki.haskell.org/Newtype">Haskell中的新类型</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">类型别名</a></li>
<li><a href="https://crates.io/crates/derive_more">derive_more</a>是一个用于在新类型上派生许多内置trait的crate。</li>
<li><a href="https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html">Rust中的新类型模式</a></li>
</ul>
<blockquote>
<p>Latest commit 11a0a13 Dec 14 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="有守护的raii"><a class="header" href="#有守护的raii">有守护的RAII</a></h1>
<h2 id="描述-5"><a class="header" href="#描述-5">描述</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>代表&quot;Resource Acquisition is Initialisation&quot;，”资源获取即初始化“。
该模式的本质是，资源初始化在对象的构造函数中完成，最终化（资源释放）在析构函数中完成。
这种模式在Rust中得到了扩展，即使用RAII对象作为某些资源的守护对象，并依靠类型系统来确保访问总是由守护对象来调解。</p>
<h2 id="例子-4"><a class="header" href="#例子-4">例子</a></h2>
<p>互斥守护是std库中这种模式的典型例子（这是真正实现的简化版本）：</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Foo {}

struct Mutex&lt;T&gt; {
    // We keep a reference to our data: T here.
    //..
}

struct MutexGuard&lt;'a, T: 'a&gt; {
    data: &amp;'a T,
    //..
}

// Locking the mutex is explicit.
impl&lt;T&gt; Mutex&lt;T&gt; {
    fn lock(&amp;self) -&gt; MutexGuard&lt;T&gt; {
        // Lock the underlying OS mutex.
        //..

        // MutexGuard keeps a reference to self
        MutexGuard {
            data: self,
            //..
        }
    }
}

// Destructor for unlocking the mutex.
impl&lt;'a, T&gt; Drop for MutexGuard&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Unlock the underlying OS mutex.
        //..
    }
}

// Implementing Deref means we can treat MutexGuard like a pointer to T.
impl&lt;'a, T&gt; Deref for MutexGuard&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.data
    }
}

fn baz(x: Mutex&lt;Foo&gt;) {
    let xx = x.lock();
    xx.foo(); // foo is a method on Foo.
    // The borrow checker ensures we can't store a reference to the underlying
    // Foo which will outlive the guard xx.

    // x is unlocked when we exit this function and xx's destructor is executed.
}
</code></pre>
<h2 id="动机-4"><a class="header" href="#动机-4">动机</a></h2>
<p>如果一个资源在使用后必须进行最终处理，RAII可以用来进行最终处理。
如果在最终处理后访问该资源是一个错误，那么这个模式可以用来防止这种错误。</p>
<h2 id="优势-2"><a class="header" href="#优势-2">优势</a></h2>
<p>防止在资源没有最终处理和在最终处理后使用资源时出现错误。</p>
<h2 id="讨论-4"><a class="header" href="#讨论-4">讨论</a></h2>
<p>RAII是一种有用的模式，可以确保资源被适当地取消分配或被最终处理。
我们可以利用Rust中的借用检查器来静态地防止在最终处理完成后使用资源所产生的错误。</p>
<p>借用检查器的核心目的是确保对数据的引用不会超过该数据的生命周期。
RAII守护模式之所以有效，是因为守护对象包含了对底层资源的引用，并且只暴露了这种引用。
Rust确保守护对象不能超过底层资源的生命周期，并且守护对象所调解资源的引用不能超过守护对象的生命周期。
为了解这一点，检查一下没有生命周期标注的<code>deref</code>的签名是有帮助的。</p>
<pre><code class="language-rust ignore">fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {
    //..
}
</code></pre>
<p>返回的资源引用与<code>self</code>具有相同的生命周期(<code>'a</code>)。
因此，借用检查器确保对<code>T</code>的引用的生命周期短于（不超过）<code>self</code>的生命周期。</p>
<p>请注意，实现<code>Deref</code>并不是这个模式的核心部分，它只是让使用守护对象更符合人体工程学。
在守护对象上实现一个<code>get</code>方法也同样有效。</p>
<h2 id="参见-5"><a class="header" href="#参见-5">参见</a></h2>
<p><a href="patterns/behavioural/../../idioms/dtor-finally.html">习语：在析构函数中的最终处理</a></p>
<p>RAII是C++中的一种常见模式：<a href="http://en.cppreference.com/w/cpp/language/raii">cppreference.com</a>,
<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">wikipedia</a>.</p>
<p><a href="https://doc.rust-lang.org/1.0.0/style/ownership/raii.html">风格指南条目</a>
（目前仅是占位符）。</p>
<blockquote>
<p>Latest commit b809265 on 22 Apr 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="策略也称-政策"><a class="header" href="#策略也称-政策">策略（也称 政策）</a></h1>
<h2 id="描述-6"><a class="header" href="#描述-6">描述</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略设计模式</a>是一种实现关注点分离的技术。它还允许通过<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖反转</a>来解耦软件模块。</p>
<p>策略模式的基本思想是，给定一个解决特定问题的算法，我们只在抽象层面上定义算法的骨架，并将具体的算法实现分成不同的部分。</p>
<p>这样，使用该算法的客户可以选择一个具体的实现，而一般的算法工作流程保持不变。
换句话说，类的抽象规范并不取决于派生类的具体实现，但具体实现必须遵守抽象规范。
这就是为什么我们称之为“依赖反转”。</p>
<h2 id="动机-5"><a class="header" href="#动机-5">动机</a></h2>
<p>想象一下，我们正在做一个每月都会生成报告的项目。
我们需要以不同的格式（策略）生成报告，例如，以<code>JSON</code>或<code>Plain Text</code>格式。
但事情随着时间的推移而变化，我们不知道未来可能得到什么样的要求。
例如，我们可能需要以一种全新的格式生成我们的报告，或者只是修改现有的一种格式。</p>
<h2 id="例子-5"><a class="header" href="#例子-5">例子</a></h2>
<p>在这个例子中，我们的不变量（或抽象）是<code>Context</code>、<code>Formatter</code>和<code>Report</code>，而<code>Text</code>和<code>Json</code>是我们的策略结构体。
这些策略必须实现<code>Formatter</code>的trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::collections::HashMap;

type Data = HashMap&lt;String, u32&gt;;

trait Formatter {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String);
}

struct Report;

impl Report {
    // Write should be used but we kept it as String to ignore error handling
    fn generate&lt;T: Formatter&gt;(g: T, s: &amp;mut String) {
        // backend operations...
        let mut data = HashMap::new();
        data.insert(&quot;one&quot;.to_string(), 1);
        data.insert(&quot;two&quot;.to_string(), 2);
        // generate report
        g.format(&amp;data, s);
    }
}

struct Text;
impl Formatter for Text {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        for (k, v) in data {
            let entry = format!(&quot;{} {}\n&quot;, k, v);
            buf.push_str(&amp;entry);
        }
    }
}

struct Json;
impl Formatter for Json {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        buf.push('[');
        for (k, v) in data.into_iter() {
            let entry = format!(r#&quot;{{&quot;{}&quot;:&quot;{}&quot;}}&quot;#, k, v);
            buf.push_str(&amp;entry);
            buf.push(',');
        }
        buf.pop(); // remove extra , at the end
        buf.push(']');
    }
}

fn main() {
    let mut s = String::from(&quot;&quot;);
    Report::generate(Text, &amp;mut s);
    assert!(s.contains(&quot;one 1&quot;));
    assert!(s.contains(&quot;two 2&quot;));

    s.clear(); // reuse the same buffer
    Report::generate(Json, &amp;mut s);
    assert!(s.contains(r#&quot;{&quot;one&quot;:&quot;1&quot;}&quot;#));
    assert!(s.contains(r#&quot;{&quot;two&quot;:&quot;2&quot;}&quot;#));
}
</code></pre></pre>
<h2 id="优势-3"><a class="header" href="#优势-3">优势</a></h2>
<p>主要优势是关注点分离。
例如，在这种情况下，<code>Report</code>对<code>Json</code>和<code>Text</code>的具体实现一无所知，而输出实现则不关心数据如何被预处理、存储和获取。
他们唯一需要知道的是上下文和要实现的特定trait和方法，即<code>Formatter</code>和<code>format</code>。</p>
<h2 id="劣势-2"><a class="header" href="#劣势-2">劣势</a></h2>
<p>每个策略必须至少有一个模块，所以模块的数量随着策略的数量而增加。
如果有许多策略可供选择，那么用户就必须知道策略之间有什么不同。</p>
<h2 id="讨论-5"><a class="header" href="#讨论-5">讨论</a></h2>
<p>在前面的例子中，所有策略都在一个文件中实现。
提供不同策略的方法包括：</p>
<ul>
<li>都在一个文件中（如本例所示，类似于作为模块分离的情况）</li>
<li>作为模块分开，例如，<code>formatter::json</code>模块，<code>formatter::text</code>模块</li>
<li>使用编译器特性标记，例如<code>json</code>特征，<code>text</code>特征</li>
<li>作为crate分开，例如：<code>json</code>crate，<code>text</code>crate</li>
</ul>
<p>Serde crate是<code>策略</code>模式在实践中的一个好例子。
Serde允许通过为我们的类型手动实现<code>Serialize</code>和<code>Deserialize</code>trait来对序列化行为进行<a href="https://serde.rs/custom-serialization.html">完全定制</a>。
例如，我们可以很容易地将<code>serde_json</code>与<code>serde_cbor</code>交换，因为它们暴露了类似的方法。
有了这一点，使得助手crate<code>serde_transcode</code>更加有用和符合人体工程学。</p>
<p>然而，我们不需要使用traits就可以在Rust中设计这种模式。</p>
<p>下面的玩具例子演示了使用Rust<code>closures</code>策略模式的想法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Adder;
impl Adder {
    pub fn add&lt;F&gt;(x: u8, y: u8, f: F) -&gt; u8
    where
        F: Fn(u8, u8) -&gt; u8,
    {
        f(x, y)
    }
}

fn main() {
    let arith_adder = |x, y| x + y;
    let bool_adder = |x, y| {
        if x == 1 || y == 1 {
            1
        } else {
            0
        }
    };
    let custom_adder = |x, y| 2 * x + y;

    assert_eq!(9, Adder::add(4, 5, arith_adder));
    assert_eq!(0, Adder::add(0, 0, bool_adder));
    assert_eq!(5, Adder::add(1, 3, custom_adder));
}

</code></pre></pre>
<p>事实上，Rust已经在<code>Options</code>的<code>map</code>方法中使用了这个想法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let val = Some(&quot;Rust&quot;);

    let len_strategy = |s: &amp;str| s.len();
    assert_eq!(4, val.map(len_strategy).unwrap());

    let first_byte_strategy = |s: &amp;str| s.bytes().next().unwrap();
    assert_eq!(82, val.map(first_byte_strategy).unwrap());
}
</code></pre></pre>
<h2 id="参见-6"><a class="header" href="#参见-6">参见</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">依赖注入</a></li>
<li><a href="https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design">基于政策的设计</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问者"><a class="header" href="#访问者">访问者</a></h1>
<h2 id="描述-7"><a class="header" href="#描述-7">描述</a></h2>
<p>访问者封装了一种在对象的异质集合上操作的算法。
它允许在同一数据上写入多种不同的算法，而不必修改数据（或其主要行为）。</p>
<p>此外，访问者模式允许将对象集合的遍历与对每个对象进行的操作分开。</p>
<h2 id="例子-6"><a class="header" href="#例子-6">例子</a></h2>
<pre><code class="language-rust ignore">// The data we will visit
mod ast {
    pub enum Stmt {
        Expr(Expr),
        Let(Name, Expr),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract visitor
mod visit {
    use ast::*;

    pub trait Visitor&lt;T&gt; {
        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T;
        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T;
        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T;
    }
}

use visit::*;
use ast::*;

// An example concrete implementation - walks the AST interpreting it as code.
struct Interpreter;
impl Visitor&lt;i64&gt; for Interpreter {
    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 { panic!() }
    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {
        match *s {
            Stmt::Expr(ref e) =&gt; self.visit_expr(e),
            Stmt::Let(..) =&gt; unimplemented!(),
        }
    }

    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {
        match *e {
            Expr::IntLit(n) =&gt; n,
            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self.visit_expr(rhs),
            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self.visit_expr(rhs),
        }
    }
}
</code></pre>
<p>人们可以实现更多的访问者，例如类型检查器，而不需要修改AST数据。</p>
<h2 id="动机-6"><a class="header" href="#动机-6">动机</a></h2>
<p>访问者模式在任何你想将算法应用于异质数据的地方都很有用。
如果数据是同质的，你可以使用一个类似迭代器的模式。
使用访问者对象（而不是功能化的方法）允许访问者是有状态的，从而在节点之间交流信息。</p>
<h2 id="讨论-6"><a class="header" href="#讨论-6">讨论</a></h2>
<p><code>visit_*</code>方法通常会返回void（与例子中不同）。
在这种情况下，有可能将遍历代码抽取出来，并在算法之间共享（也可以提供noop默认方法）。 
在Rust中，常见的方法是为每个数据点提供<code>walk_*</code>函数。
例如，</p>
<pre><code class="language-rust ignore">pub fn walk_expr(visitor: &amp;mut Visitor, e: &amp;Expr) {
    match *e {
        Expr::IntLit(_) =&gt; {},
        Expr::Add(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
        Expr::Sub(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
    }
}
</code></pre>
<p>在其他语言中（例如Java），数据通常有一个<code>accept</code>方法，担任同样的职责。</p>
<h2 id="参见-7"><a class="header" href="#参见-7">参见</a></h2>
<p>访问者模式是大多数OO语言中的一种常见模式。</p>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">访问者模式</a></p>
<p><a href="patterns/behavioural/../creational/fold.html">fold</a>模式与visitor类似，但产生一个新版本的被访数据结构。</p>
<blockquote>
<p>Latest commit b809265 on 22 Apr 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creational-patterns"><a class="header" href="#creational-patterns">Creational Patterns</a></h1>
<p>From <a href="https://en.wikipedia.org/wiki/Creational_pattern">Wikipedia</a>:</p>
<blockquote>
<p>Design patterns that deal with object creation mechanisms, trying to create objects
in a manner suitable to the situation. The basic form of object creation could
result in design problems or in added complexity to the design. Creational design
patterns solve this problem by somehow controlling this object creation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<p>Construct an object with calls to a builder helper.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h2>
<p>Useful when you would otherwise require many constructors or where
construction has side effects.</p>
<h2 id="advantages-10"><a class="header" href="#advantages-10">Advantages</a></h2>
<p>Separates methods for building from other methods.</p>
<p>Prevents proliferation of constructors</p>
<p>Can be used for one-liner initialisation as well as more complex construction.</p>
<h2 id="disadvantages-11"><a class="header" href="#disadvantages-11">Disadvantages</a></h2>
<p>More complex than creating a struct object directly, or a simple constructor
function.</p>
<h2 id="discussion-5"><a class="header" href="#discussion-5">Discussion</a></h2>
<p>This pattern is seen more frequently in Rust (and for simpler objects) than in
many other languages because Rust lacks overloading. Since you can only have a
single method with a given name, having multiple constructors is less nice in
Rust than in C++, Java, or others.</p>
<p>This pattern is often used where the builder object is useful in its own right,
rather than being just a builder. For example, see
<a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>
is a builder for <a href="https://doc.rust-lang.org/std/process/struct.Child.html"><code>Child</code></a>
(a process). In these cases, the <code>T</code> and <code>TBuilder</code> pattern
of naming is not used.</p>
<p>The example takes and returns the builder by value. It is often more ergonomic
(and more efficient) to take and return the builder as a mutable reference. The
borrow checker makes this work naturally. This approach has the advantage that
one can write code like</p>
<pre><code class="language-rust ignore">let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.build();
</code></pre>
<p>as well as the <code>FooBuilder::new().a().b().build()</code> style.</p>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See also</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">Description in the style guide</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, a crate for automatically
implementing this pattern while avoiding the boilerplate.</li>
<li><a href="patterns/creational/../../idioms/ctor.html">Constructor pattern</a> for when construction is simpler.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">Construction of complex values</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fold"><a class="header" href="#fold">Fold</a></h1>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<p>Run an algorithm over each item in a collection of data to create a new item,
thus creating a whole new collection.</p>
<p>The etymology here is unclear to me. The terms 'fold' and 'folder' are used
in the Rust compiler, although it appears to me to be more like a map than a
fold in the usual sense. See the discussion below for more details.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><code class="language-rust ignore">// The data we will fold, a simple AST.
mod ast {
    pub enum Stmt {
        Expr(Box&lt;Expr&gt;),
        Let(Box&lt;Name&gt;, Box&lt;Expr&gt;),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract folder
mod fold {
    use ast::*;

    pub trait Folder {
        // A leaf node just returns the node itself. In some cases, we can do this
        // to inner nodes too.
        fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; { n }
        // Create a new inner node by folding its children.
        fn fold_stmt(&amp;mut self, s: Box&lt;Stmt&gt;) -&gt; Box&lt;Stmt&gt; {
            match *s {
                Stmt::Expr(e) =&gt; Box::new(Stmt::Expr(self.fold_expr(e))),
                Stmt::Let(n, e) =&gt; Box::new(Stmt::Let(self.fold_name(n), self.fold_expr(e))),
            }
        }
        fn fold_expr(&amp;mut self, e: Box&lt;Expr&gt;) -&gt; Box&lt;Expr&gt; { ... }
    }
}

use fold::*;
use ast::*;

// An example concrete implementation - renames every name to 'foo'.
struct Renamer;
impl Folder for Renamer {
    fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; {
        Box::new(Name { value: &quot;foo&quot;.to_owned() })
    }
    // Use the default methods for the other nodes.
}
</code></pre>
<p>The result of running the <code>Renamer</code> on an AST is a new AST identical to the old
one, but with every name changed to <code>foo</code>. A real life folder might have some
state preserved between nodes in the struct itself.</p>
<p>A folder can also be defined to map one data structure to a different (but
usually similar) data structure. For example, we could fold an AST into a HIR
tree (HIR stands for high-level intermediate representation).</p>
<h2 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h2>
<p>It is common to want to map a data structure by performing some operation on
each node in the structure. For simple operations on simple data structures,
this can be done using <code>Iterator::map</code>. For more complex operations, perhaps
where earlier nodes can affect the operation on later nodes, or where iteration
over the data structure is non-trivial, using the fold pattern is more
appropriate.</p>
<p>Like the visitor pattern, the fold pattern allows us to separate traversal of a
data structure from the operations performed to each node.</p>
<h2 id="discussion-6"><a class="header" href="#discussion-6">Discussion</a></h2>
<p>Mapping data structures in this fashion is common in functional languages. In OO
languages, it would be more common to mutate the data structure in place. The
'functional' approach is common in Rust, mostly due to the preference for
immutability. Using fresh data structures, rather than mutating old ones, makes
reasoning about the code easier in most circumstances.</p>
<p>The trade-off between efficiency and reusability can be tweaked by changing how
nodes are accepted by the <code>fold_*</code> methods.</p>
<p>In the above example we operate on <code>Box</code> pointers. Since these own their data
exclusively, the original copy of the data structure cannot be re-used. On the
other hand if a node is not changed, reusing it is very efficient.</p>
<p>If we were to operate on borrowed references, the original data structure can be
reused; however, a node must be cloned even if unchanged, which can be
expensive.</p>
<p>Using a reference counted pointer gives the best of both worlds - we can reuse
the original data structure, and we don't need to clone unchanged nodes. However,
they are less ergonomic to use and mean that the data structures cannot be
mutable.</p>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See also</a></h2>
<p>Iterators have a <code>fold</code> method, however this folds a data structure into a
value, rather than into a new data structure. An iterator's <code>map</code> is more like
this fold pattern.</p>
<p>In other languages, fold is usually used in the sense of Rust's iterators,
rather than this pattern. Some functional languages have powerful constructs for
performing flexible maps over data structures.</p>
<p>The <a href="patterns/creational/../behavioural/visitor.html">visitor</a> pattern is closely related to fold.
They share the concept of walking a data structure performing an operation on
each node. However, the visitor does not create a new data structure nor consume
the old one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structural-patterns"><a class="header" href="#structural-patterns">Structural Patterns</a></h1>
<p>From <a href="https://en.wikipedia.org/wiki/Structural_pattern">Wikipedia</a>:</p>
<blockquote>
<p>Design patterns that ease the design by identifying a simple way to realize relationships
among entities.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compose-structs-together-for-better-borrowing"><a class="header" href="#compose-structs-together-for-better-borrowing">Compose structs together for better borrowing</a></h1>
<p>TODO - this is not a very snappy name</p>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<p>Sometimes a large struct will cause issues with the borrow checker - although
fields can be borrowed independently, sometimes the whole struct ends up being
used at once, preventing other uses. A solution might be to decompose the struct
into several smaller structs. Then compose these together into the original
struct. Then each struct can be borrowed separately and have more flexible
behaviour.</p>
<p>This will often lead to a better design in other ways: applying this design
pattern often reveals smaller units of functionality.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<p>Here is a contrived example of where the borrow checker foils us in our plan to
use a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    f1: u32,
    f2: u32,
    f3: u32,
}

fn foo(a: &amp;mut A) -&gt; &amp;u32 { &amp;a.f2 }
fn bar(a: &amp;mut A) -&gt; u32 { a.f1 + a.f3 }

fn baz(a: &amp;mut A) {
    // The later usage of x causes a to be borrowed for the rest of the function.
    let x = foo(a);
    // Borrow checker error:
    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more than once
                       //          at a time
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>We can apply this design pattern and refactor <code>A</code> into two smaller structs, thus
solving the borrow checking issue:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A is now composed of two structs - B and C.
struct A {
    b: B,
    c: C,
}
struct B {
    f2: u32,
}
struct C {
    f1: u32,
    f3: u32,
}

// These functions take a B or C, rather than A.
fn foo(b: &amp;mut B) -&gt; &amp;u32 { &amp;b.f2 }
fn bar(c: &amp;mut C) -&gt; u32 { c.f1 + c.f3 }

fn baz(a: &amp;mut A) {
    let x = foo(&amp;mut a.b);
    // Now it's OK!
    let y = bar(&amp;mut a.c);
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h2>
<p>TODO Why and where you should use the pattern</p>
<h2 id="advantages-11"><a class="header" href="#advantages-11">Advantages</a></h2>
<p>Lets you work around limitations in the borrow checker.</p>
<p>Often produces a better design.</p>
<h2 id="disadvantages-12"><a class="header" href="#disadvantages-12">Disadvantages</a></h2>
<p>Leads to more verbose code.</p>
<p>Sometimes, the smaller structs are not good abstractions, and so we end up with
a worse design. That is probably a 'code smell', indicating that the program
should be refactored in some way.</p>
<h2 id="discussion-7"><a class="header" href="#discussion-7">Discussion</a></h2>
<p>This pattern is not required in languages that don't have a borrow checker, so
in that sense is unique to Rust. However, making smaller units of functionality
often leads to cleaner code: a widely acknowledged principle of software
engineering, independent of the language.</p>
<p>This pattern relies on Rust's borrow checker to be able to borrow fields
independently of each other. In the example, the borrow checker knows that <code>a.b</code>
and <code>a.c</code> are distinct and can be borrowed independently, it does not try to
borrow all of <code>a</code>, which would make this pattern useless.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefer-small-crates"><a class="header" href="#prefer-small-crates">Prefer small crates</a></h1>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<p>Prefer small crates that do one thing well.</p>
<p>Cargo and crates.io make it easy to add third-party libraries, much more so than
in say C or C++. Moreover, since packages on crates.io cannot be edited or removed
after publication, any build that works now should continue to work in the future.
We should take advantage of this tooling, and use smaller, more fine-grained dependencies.</p>
<h2 id="advantages-12"><a class="header" href="#advantages-12">Advantages</a></h2>
<ul>
<li>Small crates are easier to understand, and encourage more modular code.</li>
<li>Crates allow for re-using code between projects.
For example, the <code>url</code> crate was developed as part of the Servo browser engine,
but has since found wide use outside the project.</li>
<li>Since the compilation unit
of Rust is the crate, splitting a project into multiple crates can allow more of
the code to be built in parallel.</li>
</ul>
<h2 id="disadvantages-13"><a class="header" href="#disadvantages-13">Disadvantages</a></h2>
<ul>
<li>This can lead to &quot;dependency hell&quot;, when a project depends on multiple conflicting
versions of a crate at the same time. For example, the <code>url</code> crate has both versions
1.0 and 0.5. Since the <code>Url</code> from <code>url:1.0</code> and the <code>Url</code> from <code>url:0.5</code> are
different types, an HTTP client that uses <code>url:0.5</code> would not accept <code>Url</code> values
from a web scraper that uses <code>url:1.0</code>.</li>
<li>Packages on crates.io are not curated. A crate may be poorly written, have
unhelpful documentation, or be outright malicious.</li>
<li>Two small crates may be less optimized than one large one, since the compiler
does not perform link-time optimization (LTO) by default.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>The <a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> crate provides functions
for converting <code>&amp;T</code> to <code>&amp;[T]</code>.</p>
<p>The <a href="https://crates.io/crates/url"><code>url</code></a> crate provides tools for working with
URLs.</p>
<p>The <a href="https://crates.io/crates/num_cpus"><code>num_cpus</code></a> crate provides a function to
query the number of CPUs on a machine.</p>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See also</a></h2>
<ul>
<li><a href="https://crates.io/">crates.io: The Rust community crate host</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contain-unsafety-in-small-modules"><a class="header" href="#contain-unsafety-in-small-modules">Contain unsafety in small modules</a></h1>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<p>If you have <code>unsafe</code> code, create the smallest possible module that can uphold
the needed invariants to build a minimal safe interface upon the unsafety. Embed
this into a larger module that contains only safe code and presents an ergonomic
interface. Note that the outer module can contain unsafe functions and methods
that call directly into the unsafe code. Users may use this to gain speed benefits.</p>
<h2 id="advantages-13"><a class="header" href="#advantages-13">Advantages</a></h2>
<ul>
<li>This restricts the unsafe code that must be audited</li>
<li>Writing the outer module is much easier, since you can count on the guarantees
of the inner module</li>
</ul>
<h2 id="disadvantages-14"><a class="header" href="#disadvantages-14">Disadvantages</a></h2>
<ul>
<li>Sometimes, it may be hard to find a suitable interface.</li>
<li>The abstraction may introduce inefficiencies.</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li>The <a href="https://docs.rs/toolshed"><code>toolshed</code></a> crate contains its unsafe operations
in submodules, presenting a safe interface to users.</li>
<li><code>std</code>'s <code>String</code> class is a wrapper over <code>Vec&lt;u8&gt;</code> with the added invariant
that the contents must be valid UTF-8. The operations on <code>String</code> ensure this
behavior.
However, users have the option of using an <code>unsafe</code> method to create a <code>String</code>,
in which case the onus is on them to guarantee the validity of the contents.</li>
</ul>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See also</a></h2>
<ul>
<li><a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">Ralf Jung's Blog about invariants in unsafe code</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-patterns"><a class="header" href="#ffi-patterns">FFI Patterns</a></h1>
<p>Writing FFI code is an entire course in itself.
However, there are several idioms here that can act as pointers, and avoid traps
for inexperienced users of unsafe Rust.</p>
<p>This section contains design patterns that may be useful when doing FFI.</p>
<ol>
<li>
<p><a href="patterns/ffi/./export.html">Object-Based API</a> design that has good memory safety characteristics,
and a clean boundary of what is safe and what is unsafe</p>
</li>
<li>
<p><a href="patterns/ffi/./wrappers.html">Type Consolidation into Wrappers</a> - group multiple Rust types
together into an opaque &quot;object&quot;</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-based-apis"><a class="header" href="#object-based-apis">Object-Based APIs</a></h1>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<p>When designing APIs in Rust which are exposed to other languages, there are some
important design principles which are contrary to normal Rust API design:</p>
<ol>
<li>All Encapsulated types should be <em>owned</em> by Rust, <em>managed</em> by the user,
and <em>opaque</em>.</li>
<li>All Transactional data types should be <em>owned</em> by the user, and <em>transparent</em>.</li>
<li>All library behavior should be functions acting upon Encapsulated types.</li>
<li>All library behavior should be encapsulated into types not based on structure,
but <em>provenance/lifetime</em>.</li>
</ol>
<h2 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h2>
<p>Rust has built-in FFI support to other languages.
It does this by providing a way for crate authors to provide C-compatible APIs
through different ABIs (though that is unimportant to this practice).</p>
<p>Well-designed Rust FFI follows C API design principles, while compromising the
design in Rust as little as possible. There are three goals with any foreign API:</p>
<ol>
<li>Make it easy to use in the target language.</li>
<li>Avoid the API dictating internal unsafety on the Rust side as much as possible.</li>
<li>Keep the potential for memory unsafety and Rust <code>undefined behaviour</code> as small
as possible.</li>
</ol>
<p>Rust code must trust the memory safety of the foreign language beyond a certain
point. However, every bit of <code>unsafe</code> code on the Rust side is an opportunity for
bugs, or to exacerbate <code>undefined behaviour</code>.</p>
<p>For example, if a pointer provenance is wrong, that may be a segfault due to
invalid memory access. But if it is manipulated by unsafe code, it could become
full-blown heap corruption.</p>
<p>The Object-Based API design allows for writing shims that have good memory safety
characteristics, and a clean boundary of what is safe and what is <code>unsafe</code>.</p>
<h2 id="code-example-3"><a class="header" href="#code-example-3">Code Example</a></h2>
<p>The POSIX standard defines the API to access an on-file database, known as <a href="https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h">DBM</a>.
It is an excellent example of an &quot;object-based&quot; API.</p>
<p>Here is the definition in C, which hopefully should be easy to read for those
involved in FFI. The commentary below should help explain it for those who
miss the subtleties.</p>
<pre><code class="language-C">struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
</code></pre>
<p>This API defines two types: <code>DBM</code> and <code>datum</code>.</p>
<p>The <code>DBM</code> type was called an &quot;encapsulated&quot; type above.
It is designed to contain internal state, and acts as an entry point for the
library's behavior.</p>
<p>It is completely opaque to the user, who cannot create a <code>DBM</code> themselves since
they don't know its size or layout. Instead, they must call <code>dbm_open</code>, and that
only gives them <em>a pointer to one</em>.</p>
<p>This means all <code>DBM</code>s are &quot;owned&quot; by the library in a Rust sense.
The internal state of unknown size is kept in memory controlled by the library,
not the user. The user can only manage its life cycle with <code>open</code> and <code>close</code>,
and perform operations on it with the other functions.</p>
<p>The <code>datum</code> type was called a &quot;transactional&quot; type above.
It is designed to facilitate the exchange of information between the library and
its user.</p>
<p>The database is designed to store &quot;unstructured data&quot;, with no pre-defined length
or meaning. As a result, the <code>datum</code> is the C equivalent of a Rust slice: a bunch
of bytes, and a count of how many there are. The main difference is that there is
no type information, which is what <code>void</code> indicates.</p>
<p>Keep in mind that this header is written from the library's point of view.
The user likely has some type they are using, which has a known size.
But the library does not care, and by the rules of C casting, any type behind a
pointer can be cast to <code>void</code>.</p>
<p>As noted earlier, this type is <em>transparent</em> to the user. But also, this type is
<em>owned</em> by the user.
This has subtle ramifications, due to that pointer inside it.
The question is, who owns the memory that pointer points to?</p>
<p>The answer for best memory safety is, &quot;the user&quot;.
But in cases such as retrieving a value, the user does not know how to allocate
it correctly (since they don't know how long the value is). In this case, the library
code is expected to use the heap that the user has access to -- such as the C library
<code>malloc</code> and <code>free</code> -- and then <em>transfer ownership</em> in the Rust sense.</p>
<p>This may all seem speculative, but this is what a pointer means in C.
It means the same thing as Rust: &quot;user defined lifetime.&quot;
The user of the library needs to read the documentation in order to use it correctly.
That said, there are some decisions that have fewer or greater consequences if users
do it wrong. Minimizing those are what this best practice is about, and the key
is to <em>transfer ownership of everything that is transparent</em>.</p>
<h2 id="advantages-14"><a class="header" href="#advantages-14">Advantages</a></h2>
<p>This minimizes the number of memory safety guarantees the user must uphold to a
relatively small number:</p>
<ol>
<li>Do not call any function with a pointer not returned by <code>dbm_open</code> (invalid
access or corruption).</li>
<li>Do not call any function on a pointer after close (use after free).</li>
<li>The <code>dptr</code> on any <code>datum</code> must be <code>NULL</code>, or point to a valid slice of memory
at the advertised length.</li>
</ol>
<p>In addition, it avoids a lot of pointer provenance issues.
To understand why, let us consider an alternative in some depth: key iteration.</p>
<p>Rust is well known for its iterators.
When implementing one, the programmer makes a separate type with a bounded lifetime
to its owner, and implements the <code>Iterator</code> trait.</p>
<p>Here is how iteration would be done in Rust for <code>DBM</code>:</p>
<pre><code class="language-rust ignore">struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys&lt;'it&gt;(&amp;'it self) -&gt; DbmKeysIter&lt;'it&gt; { ... }
    /* ... */
}

struct DbmKeysIter&lt;'it&gt; {
    owner: &amp;'it Dbm,
}

impl&lt;'it&gt; Iterator for DbmKeysIter&lt;'it&gt; { ... }
</code></pre>
<p>This is clean, idiomatic, and safe. thanks to Rust's guarantees.
However, consider what a straightforward API translation would look like:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_new(owner: *const Dbm) -&gt; *mut DbmKeysIter {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -&gt; libc::c_int {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_del(*mut DbmKeysIter) {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
</code></pre>
<p>This API loses a key piece of information: the lifetime of the iterator must not
exceed the lifetime of the <code>Dbm</code> object that owns it. A user of the library could
use it in a way which causes the iterator to outlive the data it is iterating on,
resulting in reading uninitialized memory.</p>
<p>This example written in C contains a bug that will be explained afterwards:</p>
<pre><code class="language-C">int count_key_sizes(DBM *db) {
    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &amp;key)) &gt;= 0) { // an error is indicated by -1
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // end of the iterator
            dbm_close(owner);
        }
    }
    if l &gt;= 0 {
        return -1;
    } else {
        return len;
    }
}
</code></pre>
<p>This bug is a classic. Here's what happens when the iterator returns the
end-of-iteration marker:</p>
<ol>
<li>The loop condition sets <code>l</code> to zero, and enters the loop because <code>0 &gt;= 0</code>.</li>
<li>The length is incremented, in this case by zero.</li>
<li>The if statement is true, so the database is closed. There should be a break
statement here.</li>
<li>The loop condition executes again, causing a <code>next</code> call on the closed object.</li>
</ol>
<p>The worst part about this bug?
If the Rust implementation was careful, this code will work most of the time!
If the memory for the <code>Dbm</code> object is not immediately reused, an internal check
will almost certainly fail, resulting in the iterator returning a <code>-1</code> indicating
an error. But occasionally, it will cause a segmentation fault, or even worse,
nonsensical memory corruption!</p>
<p>None of this can be avoided by Rust.
From its perspective, it put those objects on its heap, returned pointers to them,
and gave up control of their lifetimes. The C code simply must &quot;play nice&quot;.</p>
<p>The programmer must read and understand the API documentation.
While some consider that par for the course in C, a good API design can mitigate
this risk. The POSIX API for <code>DBM</code> did this by <em>consolidating the ownership</em> of
the iterator with its parent:</p>
<pre><code class="language-C">datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
</code></pre>
<p>Thus, all the lifetimes were bound together, and such unsafety was prevented.</p>
<h2 id="disadvantages-15"><a class="header" href="#disadvantages-15">Disadvantages</a></h2>
<p>However, this design choice also has a number of drawbacks, which should be
considered as well.</p>
<p>First, the API itself becomes less expressive.
With POSIX DBM, there is only one iterator per object, and every call changes
its state. This is much more restrictive than iterators in almost any language,
even though it is safe. Perhaps with other related objects, whose lifetimes are
less hierarchical, this limitation is more of a cost than the safety.</p>
<p>Second, depending on the relationships of the API's parts, significant design effort
may be involved. Many of the easier design points have other patterns associated
with them:</p>
<ul>
<li>
<p><a href="patterns/ffi/./wrappers.html">Wrapper Type Consolidation</a> groups multiple Rust types together
into an opaque &quot;object&quot;</p>
</li>
<li>
<p><a href="patterns/ffi/../../idioms/ffi/errors.html">FFI Error Passing</a> explains error handling with integer
codes and sentinel return values (such as <code>NULL</code> pointers)</p>
</li>
<li>
<p><a href="patterns/ffi/../../idioms/ffi/accepting-strings.html">Accepting Foreign Strings</a> allows accepting
strings with minimal unsafe code, and is easier to get right than
<a href="patterns/ffi/../../idioms/ffi/passing-strings.html">Passing Strings to FFI</a></p>
</li>
</ul>
<p>However, not every API can be done this way.
It is up to the best judgement of the programmer as to who their audience is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-consolidation-into-wrappers"><a class="header" href="#type-consolidation-into-wrappers">Type Consolidation into Wrappers</a></h1>
<h2 id="description-20"><a class="header" href="#description-20">Description</a></h2>
<p>This pattern is designed to allow gracefully handling multiple related types,
while minimizing the surface area for memory unsafety.</p>
<p>One of the cornerstones of Rust's aliasing rules is lifetimes.
This ensures that many patterns of access between types can be memory safe,
data race safety included.</p>
<p>However, when Rust types are exported to other languages, they are usually transformed
into pointers. In Rust, a pointer means &quot;the user manages the lifetime of the pointee.&quot;
It is their responsibility to avoid memory unsafety.</p>
<p>Some level of trust in the user code is thus required, notably around use-after-free
which Rust can do nothing about. However, some API designs place higher burdens
than others on the code written in the other language.</p>
<p>The lowest risk API is the &quot;consolidated wrapper&quot;, where all possible interactions
with an object are folded into a &quot;wrapper type&quot;, while keeping the Rust API clean.</p>
<h2 id="code-example-4"><a class="header" href="#code-example-4">Code Example</a></h2>
<p>To understand this, let us look at a classic example of an API to export: iteration
through a collection.</p>
<p>That API looks like this:</p>
<ol>
<li>The iterator is initialized with <code>first_key</code>.</li>
<li>Each call to <code>next_key</code> will advance the iterator.</li>
<li>Calls to <code>next_key</code> if the iterator is at the end will do nothing.</li>
<li>As noted above, the iterator is &quot;wrapped into&quot; the collection (unlike the native
Rust API).</li>
</ol>
<p>If the iterator implements <code>nth()</code> efficiently, then it is possible to make it
ephemeral to each function call:</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}
</code></pre>
<p>As a result, the wrapper is simple and contains no <code>unsafe</code> code.</p>
<h2 id="advantages-15"><a class="header" href="#advantages-15">Advantages</a></h2>
<p>This makes APIs safer to use, avoiding issues with lifetimes between types.
See <a href="patterns/ffi/./export.html">Object-Based APIs</a> for more on the advantages and pitfalls
this avoids.</p>
<h2 id="disadvantages-16"><a class="header" href="#disadvantages-16">Disadvantages</a></h2>
<p>Often, wrapping types is quite difficult, and sometimes a Rust API compromise
would make things easier.</p>
<p>As an example, consider an iterator which does not efficiently implement <code>nth()</code>.
It would definitely be worth putting in special logic to make the object handle
iteration internally, or to support a different access pattern efficiently that
only the Foreign Function API will use.</p>
<h3 id="trying-to-wrap-iterators-and-failing"><a class="header" href="#trying-to-wrap-iterators-and-failing">Trying to Wrap Iterators (and Failing)</a></h3>
<p>To wrap any type of iterator into the API correctly, the wrapper would need to
do what a C version of the code would do: erase the lifetime of the iterator,
and manage it manually.</p>
<p>Suffice it to say, this is <em>incredibly</em> difficult.</p>
<p>Here is an illustration of just <em>one</em> pitfall.</p>
<p>A first version of <code>MySetWrapper</code> would look like this:</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // created from a transmuted Box&lt;KeysIter + 'self&gt;
    iterator: Option&lt;NonNull&lt;KeysIter&lt;'static&gt;&gt;&gt;,
}
</code></pre>
<p>With <code>transmute</code> being used to extend a lifetime, and a pointer to hide it,
it's ugly already. But it gets even worse: <em>any other operation can cause
Rust <code>undefined behaviour</code></em>.</p>
<p>Consider that the <code>MySet</code> in the wrapper could be manipulated by other
functions during iteration, such as storing a new value to the key it was
iterating over. The API doesn't discourage this, and in fact some similar C
libraries expect it.</p>
<p>A simple implementation of <code>myset_store</code> would be:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub fn myset_store(
        myset: *mut MySetWrapper,
        key: datum,
        value: datum) -&gt; libc::c_int {

        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.

        let myset: &amp;mut MySet = unsafe { // SAFETY: whoops, UB occurs in here!
            &amp;mut (*myset).myset
        };

        /* ...check and cast key and value data... */

        match myset.store(casted_key, casted_value) {
            Ok(_) =&gt; 0,
            Err(e) =&gt; e.into()
        }
    }
}
</code></pre>
<p>If the iterator exists when this function is called, we have violated one of Rust's
aliasing rules. According to Rust, the mutable reference in this block must have
<em>exclusive</em> access to the object. If the iterator simply exists, it's not exclusive,
so we have <code>undefined behaviour</code>! <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>To avoid this, we must have a way of ensuring that mutable reference really is exclusive.
That basically means clearing out the iterator's shared reference while it exists,
and then reconstructing it. In most cases, that will still be less efficient than
the C version.</p>
<p>Some may ask: how can C do this more efficiently?
The answer is, it cheats. Rust's aliasing rules are the problem, and C simply ignores
them for its pointers. In exchange, it is common to see code that is declared
in the manual as &quot;not thread safe&quot; under some or all circumstances. In fact,
the <a href="https://manpages.debian.org/buster/manpages/attributes.7.en.html">GNU C library</a>
has an entire lexicon dedicated to concurrent behavior!</p>
<p>Rust would rather make everything memory safe all the time, for both safety and
optimizations that C code cannot attain. Being denied access to certain shortcuts
is the price Rust programmers need to pay.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For the C programmers out there scratching their heads, the iterator need
not be read <em>during</em> this code cause the UB. The exclusivity rule also enables
compiler optimizations which may cause inconsistent observations by the iterator's
shared reference (e.g. stack spills or reordering instructions for efficiency).
These observations may happen <em>any time after</em> the mutable reference is created.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反面模式"><a class="header" href="#反面模式">反面模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Anti-pattern">反面模式</a>是一种解决反复出现的问题的方法，通常是无效的，并有可能产生很大的反面作用。与知道如何解决一个问题一样有价值的是知道<strong>不能</strong>这样解决这个问题。相对于设计模式，反面模式给我们提供了很好的反例来考虑。反面模式并不局限于代码。例如，一个流程也可以是一个反面模式。</p>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过clone来满足借用检查器"><a class="header" href="#通过clone来满足借用检查器">通过Clone来满足借用检查器</a></h1>
<h2 id="描述-8"><a class="header" href="#描述-8">描述</a></h2>
<p>借用检查器通过确保以下两种情况来防止Rust用户开发不安全的代码：只存在一个可变引用，或者可能存在多个但都是不可变引用。
如果编写的代码不符合这些条件，当开发者通过克隆变量来解决编译器错误时，就会出现这种反面模式。</p>
<h2 id="例子-7"><a class="header" href="#例子-7">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &amp;mut (x.clone());

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机-7"><a class="header" href="#动机-7">动机</a></h2>
<p>特别是对初学者来说，用这种模式来解决借用检查器的迷惑问题是很诱人的。
然而，这有严重的后果。使用<code>.clone()</code>会导致数据被复制。
两者之间的任何变化都是不同步的——就像存在两个完全独立的变量一样。</p>
<p>有一些特殊情况——<code>Rc&lt;T&gt;</code>被设计用来智能地处理克隆。
它在内部精确地管理着一份数据的副本，克隆它只会克隆引用。</p>
<p>还有<code>Arc&lt;T&gt;</code>，它提供了在堆中分配的T类型的值的共享所有权。
对<code>Arc</code>调用<code>.clone()</code>会产生一个新的<code>Arc</code>实例，它指向与源<code>Arc</code>相同的堆上的分配，同时增加一个引用计数。</p>
<p>一般来说，克隆应该是深思熟虑的，并充分了解后果。
如果克隆被用来使借用检查器的错误消失，那就很可能说明这种反面模式可能在使用。</p>
<p>尽管<code>.clone()</code>暗示着不好的模式，但有时<strong>写低效的代码也是可以的</strong>，例如在以下情况下：</p>
<ul>
<li>开发者仍然对所有权不熟悉</li>
<li>代码没有很大的速度或内存限制（如黑客马拉松项目或原型）</li>
<li>满足借用检查器相当复杂，而你更愿意优化可读性而不是性能</li>
</ul>
<p>如果怀疑有不必要的克隆，在评估是否需要克隆之前，应该充分理解<a href="https://doc.rust-lang.org/book/ownership.html">Rust Book的所有权章节</a></p>
<p>此外，请确保在你的项目中始终运行<code>cargo clippy</code>，它将检测到一些不需要<code>.clone()</code>的情况，例如<a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone">1</a>,
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy">2</a>,
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#map_clone">3</a>或<a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref">4</a>.</p>
<h2 id="参见-8"><a class="header" href="#参见-8">参见</a></h2>
<ul>
<li><a href="anti_patterns/../idioms/mem-replace.html">在发生改变的枚举中使用<code>mem::{take(_), replace(_)}</code>来保留所有值</a></li>
<li><a href="http://doc.rust-lang.org/std/rc/"><code>Rc&lt;T&gt;</code>文档，用于智能地处理.clone()</a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code>文档，线程安全的引用计数指针</a></li>
<li><a href="https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html">Rust中关于所有权的技巧</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="denywarnings"><a class="header" href="#denywarnings"><code>#![deny(warnings)]</code></a></h1>
<h2 id="描述-9"><a class="header" href="#描述-9">描述</a></h2>
<p>一个善意的crate作者想确保他们的代码在构建时不会出现警告。所以他用以下内容来注释其crate根。</p>
<h2 id="例子-8"><a class="header" href="#例子-8">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![deny(warnings)]

<span class="boring">fn main() {
</span>// All is well.
<span class="boring">}
</span></code></pre></pre>
<h2 id="优势-4"><a class="header" href="#优势-4">优势</a></h2>
<p>注释很短，如果出现错误，会停止构建。</p>
<h2 id="劣势-3"><a class="header" href="#劣势-3">劣势</a></h2>
<p>通过不允许编译器产生构建警告，crate作者失去了Rust引以为傲的稳定性。 
有时，新特性或旧的错误特性需要改变处理逻辑，因此，在转为<code>deny</code>之前，会有<code>warn</code>的lint，并有一定的缓冲期。</p>
<p>例如，人们发现一个类型可以有两个具有相同方法的<code>impl</code>块。
这被认为是一个坏主意，但为了使过渡顺利，<code>overlapping-inherent-impls</code> lint被引入，给那些偶然发现这个事实的人一个警告，即使它在未来的版本中将成为一个硬编码错误。</p>
<p>另外，有时API会被废弃，所以在它们消失前使用会发出警告。</p>
<p>当某些事情发生改变，所有这些都有潜在的破坏构建的可能性。</p>
<p>此外，提供额外lint的crate（例如<a href="https://github.com/Manishearth/rust-clippy">rust-clippy</a>）不能再被使用，除非注释被删除。这可以通过[-cap-lints]来缓解。
命令行参数<code>--cap-lints=warn</code>可将所有<code>deny</code>lint错误变成警告。</p>
<h2 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h2>
<p>有两种方法可以解决这个问题：第一，我们可以将构建设置与代码解耦；第二，我们可以指明我们想要显式拒绝的lint。</p>
<p>下面的命令行参数在所有警告设置为<code>deny</code>的情况下构建：</p>
<p><code>RUSTFLAGS=&quot;-D warnings&quot; cargo build</code></p>
<p>这可以由任何个人开发者完成（或者在Travis这样的CI工具中设置，但请记住，当有变化时，这可能会破坏构建），而不需要对代码进行修改。</p>
<p>另外，我们可以在代码中指定我们想要<code>deny</code>的lint。
下面是一个（希望）可以安全拒绝的警告lint的列表（截至Rustc 1.48.0）:</p>
<pre><code class="language-rust ignore">#[deny(bad-style,
       const-err,
       dead-code,
       improper-ctypes,
       non-shorthand-field-patterns,
       no-mangle-generic-items,
       overflowing-literals,
       path-statements ,
       patterns-in-fns-without-body,
       private-in-public,
       unconditional-recursion,
       unused,
       unused-allocation,
       unused-comparisons,
       unused-parens,
       while-true)]
</code></pre>
<p>此外，以下<code>allow</code>lint可能是一个<code>deny</code>的好主意。</p>
<pre><code class="language-rust ignore">#[deny(missing-debug-implementations,
       missing-docs,
       trivial-casts,
       trivial-numeric-casts,
       unused-extern-crates,
       unused-import-braces,
       unused-qualifications,
       unused-results)]
</code></pre>
<p>有些人可能还想在他们的列表中加入<code>missing-copy-implementations</code>lint。</p>
<p>请注意，我们没有明确添加<code>deprecated</code>的lint，因为可以肯定的是，未来会有更多被废弃的API。</p>
<h2 id="参见-9"><a class="header" href="#参见-9">参见</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master">所有的clippy lints</a></li>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#deprecation">deprecate attribute</a>文档</li>
<li>输入<code>rustc -W help</code>可查看你系统上的lint。也可以输入
<code>rustc --help</code>查看选项。</li>
<li><a href="https://github.com/Manishearth/rust-clippy">rust-clippy</a>是一个用于写出更好的Rust代码的lint集合。</li>
</ul>
<blockquote>
<p>Latest commit 39a2f36 on 18 Oct 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-多态性"><a class="header" href="#deref-多态性"><code>Deref</code> 多态性</a></h1>
<h2 id="描述-10"><a class="header" href="#描述-10">描述</a></h2>
<p>滥用<code>Deref</code> trait来模拟结构体间的继承，从而重用方法。</p>
<h2 id="例子-9"><a class="header" href="#例子-9">例子</a></h2>
<p>有时我们想模仿以下来自OO语言（如Java）的常见模式：</p>
<pre><code class="language-java">class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
</code></pre>
<p>我们可以使用deref多态性的反面模式来做到这一点：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
</code></pre></pre>
<p>Rust中没有结构体的继承。相反，我们使用组合，并在<code>Bar</code>中包含一个<code>Foo</code>的实例（因为字段是一个值，它被内联存储，所以如果有字段，它们在内存中的布局与Java版本相同（可能，如果你想确定，你应该使用<code>#[repr(C)]</code>））。</p>
<p>为了使方法调用生效，我们为<code>Bar</code>实现了<code>Deref</code>，以<code>Foo</code>为目标（返回嵌入的<code>Foo</code>字段）。这意味着当我们解除对<code>Bar</code>的引用时（例如，使用<code>*</code>），我们将得到一个<code>Foo</code>。
这很奇怪。解引用通常从对<code>T</code>的引用中得到一个<code>T</code>，这里我们有两个不相关的类型。
然而，由于点运算符做了隐式解引用，这意味着方法调用将搜索<code>Foo</code>和<code>Bar</code>的方法。</p>
<h2 id="优势-5"><a class="header" href="#优势-5">优势</a></h2>
<p>你可以节省一点模板代码，例如：</p>
<pre><code class="language-rust ignore">impl Bar {
    fn m(&amp;self) {
        self.f.m()
    }
}
</code></pre>
<h2 id="劣势-4"><a class="header" href="#劣势-4">劣势</a></h2>
<p>最重要的是这是一个令人惊讶的习语--未来的程序员在代码中读到这句话时，不会想到会发生这种情况。
这既因为我们在滥用<code>Deref</code> trait，而不是按照预期（文档等）使用它。
也因为这里的机制是完全隐含的。</p>
<p>这种模式没有像Java或C++中的继承那样在<code>Foo</code>和<code>Bar</code>之间引入子类型。此外，由<code>Foo</code>实现的特性不会自动为<code>Bar</code>实现，所以这种模式与边界检查以及泛型编程的互动性很差。</p>
<p>使用这种模式，在<code>self</code>的语义上与大多数OO语言有细微的不同。
通常情况下，它仍然是对子类的引用，在这种模式下，它将是定义方法的&quot;类&quot;。</p>
<p>最后，这种模式只支持单继承，没有接口的概念，没有基于类的隐私，也没有其他与继承有关的特性。
所以，它给人的体验会让习惯了Java继承等的程序员感到微妙的惊讶。</p>
<h2 id="讨论-7"><a class="header" href="#讨论-7">讨论</a></h2>
<p>我们没有一个好的替代方案。根据具体的情况，使用traits重新实现或者手动写出派发给<code>Foo</code>的facade方法可能更好。
我们确实打算在Rust中加入与此类似的继承机制，但要达到稳定的Rust，可能还需要一些时间。详情可见：
<a href="http://aturon.github.io/blog/2015/09/18/reuse/">blog</a>
<a href="http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/">posts</a>
and this <a href="https://github.com/rust-lang/rfcs/issues/349">RFC issue</a></p>
<p><code>Deref</code> trait 是为实现自定义指针类型而设计的。
目的是让它通过指向<code>T</code>的指针到达<code>T</code>，而不是在不同类型之间转换。
遗憾的是，这一点并没有（也许不能）由trait定义强制执行。</p>
<p>Rust试图在显式和隐式机制之间取得谨慎的平衡，倾向于类型之间的显式转换。
点运算符中的自动解引用是一个人机工程学强烈支持隐式机制的情况，但其目的是将其限制在间接程度上，而不是在任意类型之间的转换。</p>
<h2 id="参见-10"><a class="header" href="#参见-10">参见</a></h2>
<ul>
<li><a href="anti_patterns/../idioms/deref.html">集合是智能指针的习语</a>.</li>
<li>为了较少的模板代码的代表crate <a href="https://crates.io/crates/delegate">delegate</a>
或<a href="https://crates.io/crates/ambassador">ambassador</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code> trait文档</a>.</li>
</ul>
<blockquote>
<p>Latest commit fb57f21 on 10 Mar 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-usage-of-rust"><a class="header" href="#functional-usage-of-rust">Functional Usage of Rust</a></h1>
<p>Rust is an imperative language, but it follows many
<a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> paradigms.</p>
<blockquote>
<p>In computer science, <em>functional programming</em> is a programming paradigm where
programs are constructed by applying and composing functions.
It is a declarative programming paradigm in which function definitions are
trees of expressions that each return a value, rather than a sequence of
imperative statements which change the state of the program.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-paradigms"><a class="header" href="#programming-paradigms">Programming paradigms</a></h1>
<p>One of the biggest hurdles to understanding functional programs when coming
from an imperative background is the shift in thinking. Imperative programs
describe <strong>how</strong> to do something, whereas declarative programs describe
<strong>what</strong> to do. Let's sum the numbers from 1 to 10 to show this.</p>
<h2 id="imperative"><a class="header" href="#imperative">Imperative</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!(&quot;{}&quot;, sum);
<span class="boring">}
</span></code></pre></pre>
<p>With imperative programs, we have to play compiler to see what is happening.
Here, we start with a <code>sum</code> of <code>0</code>.
Next, we iterate through the range from 1 to 10.
Each time through the loop, we add the corresponding value in the range.
Then we print it out.</p>
<table><thead><tr><th align="center"><code>i</code></th><th align="center"><code>sum</code></th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<p>This is how most of us start out programming. We learn that a program is a set
of steps.</p>
<h2 id="declarative"><a class="header" href="#declarative">Declarative</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (1..11).fold(0, |a, b| a + b));
<span class="boring">}
</span></code></pre></pre>
<p>Whoa! This is really different! What's going on here?
Remember that with declarative programs we are describing <strong>what</strong> to do,
rather than <strong>how</strong> to do it. <code>fold</code> is a function that <a href="https://en.wikipedia.org/wiki/Function_composition">composes</a>
functions. The name is a convention from Haskell.</p>
<p>Here, we are composing functions of addition (this closure: <code>|a, b| a + b</code>)
with a range from 1 to 10. The <code>0</code> is the starting point, so <code>a</code> is <code>0</code> at
first. <code>b</code> is the first element of the range, <code>1</code>. <code>0 + 1 = 1</code> is the result.
So now we <code>fold</code> again, with <code>a = 1</code>, <code>b = 2</code> and so <code>1 + 2 = 3</code> is the next
result. This process continues until we get to the last element in the range,
<code>10</code>.</p>
<table><thead><tr><th align="center"><code>a</code></th><th align="center"><code>b</code></th><th align="center">result</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">6</td><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">10</td><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">15</td><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">21</td><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">28</td><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">36</td><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">45</td><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-as-type-classes"><a class="header" href="#generics-as-type-classes">Generics as Type Classes</a></h1>
<h2 id="description-21"><a class="header" href="#description-21">Description</a></h2>
<p>Rust's type system is designed more like functional languages (like Haskell)
rather than imperative languages (like Java and C++). As a result, Rust can turn
many kinds of programming problems into &quot;static typing&quot; problems. This is one
of the biggest wins of choosing a functional language, and is critical to many
of Rust's compile time guarantees.</p>
<p>A key part of this idea is the way generic types work. In C++ and Java, for
example, generic types are a meta-programming construct for the compiler.
<code>vector&lt;int&gt;</code> and <code>vector&lt;char&gt;</code> in C++ are just two different copies of the
same boilerplate code for a <code>vector</code> type (known as a <code>template</code>)  with two
different types filled in.</p>
<p>In Rust, a generic type parameter creates what is known in functional languages
as a &quot;type class constraint&quot;, and each different parameter filled in by an end
user <em>actually changes the type</em>. In other words, <code>Vec&lt;isize&gt;</code> and <code>Vec&lt;char&gt;</code>
<em>are two different types</em>, which are recognized as distinct by all parts of the
type system.</p>
<p>This is called <strong>monomorphization</strong>, where different types are created from
<strong>polymorphic</strong> code.  This special behavior requires <code>impl</code> blocks to specify
generic parameters: different values for the generic type cause different types,
and different types can have different <code>impl</code> blocks.</p>
<p>In object-oriented languages, classes can inherit behavior from their parents.
However, this allows the attachment of not only additional behavior to
particular members of a type class, but extra behavior as well.</p>
<p>The nearest equivalent is the runtime polymorphism in Javascript and Python,
where new members can be added to objects willy-nilly by any constructor.
Unlike those languages, however, all of Rust's additional methods can be type
checked when they are used, because their generics are statically defined. That
makes them more usable while remaining safe.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<p>Suppose you are designing a storage server for a series of lab machines.
Because of the software involved, there are two different protocols you need
to support: BOOTP (for PXE network boot), and NFS (for remote mount storage).</p>
<p>Your goal is to have one program, written in Rust, which can handle both of
them. It will have protocol handlers and listen for both kinds of requests. The
main application logic will then allow a lab administrator to configure storage
and security controls for the actual files.</p>
<p>The requests from machines in the lab for files contain the same basic
information, no matter what protocol they came from: an authentication method,
and a file name to retrieve.  A straightforward implementation would look
something like this:</p>
<pre><code class="language-rust ignore">
enum AuthInfo {
    Nfs(crate::nfs::AuthInfo),
    Bootp(crate::bootp::AuthInfo),
}

struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
}
</code></pre>
<p>This design might work well enough. But now suppose you needed to support
adding metadata that was <em>protocol specific</em>. For example, with NFS, you
wanted to determine what their mount point was in order to enforce additional
security rules.</p>
<p>The way the current struct is designed leaves the protocol decision until
runtime. That means any method that applies to one protocol and not the other
requires the programmer to do a runtime check.</p>
<p>Here is how getting an NFS mount point would look:</p>
<pre><code class="language-rust ignore">struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
    mount_point: Option&lt;PathBuf&gt;,
}

impl FileDownloadRequest {
    // ... other methods ...

    /// Gets an NFS mount point if this is an NFS request. Otherwise,
    /// return None.
    pub fn mount_point(&amp;self) -&gt; Option&lt;&amp;Path&gt; {
        self.mount_point.as_ref()
    }
}
</code></pre>
<p>Every caller of <code>mount_point()</code> must check for <code>None</code> and write code to handle
it. This is true even if they know only NFS requests are ever used in a given
code path!</p>
<p>It would be far more optimal to cause a compile-time error if the different
request types were confused. After all, the entire path of the user's code,
including what functions from the library they use, will know whether a request
is an NFS request or a BOOTP request.</p>
<p>In Rust, this is actually possible! The solution is to <em>add a generic type</em> in
order to split the API.</p>
<p>Here is what that looks like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::path::{Path, PathBuf};

mod nfs {
    #[derive(Clone)]
    pub(crate) struct AuthInfo(String); // NFS session management omitted
}

mod bootp {
    pub(crate) struct AuthInfo(); // no authentication in bootp
}

// private module, lest outside users invent their own protocol kinds!
mod proto_trait {
    use std::path::{Path, PathBuf};
    use super::{bootp, nfs};

    pub(crate) trait ProtoKind {
        type AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo;
    }

    pub struct Nfs {
        auth: nfs::AuthInfo,
        mount_point: PathBuf,
    }

    impl Nfs {
        pub(crate) fn mount_point(&amp;self) -&gt; &amp;Path {
            &amp;self.mount_point
        }
    }

    impl ProtoKind for Nfs {
        type AuthInfo = nfs::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            self.auth.clone()
        }
    }

    pub struct Bootp(); // no additional metadata

    impl ProtoKind for Bootp {
        type AuthInfo = bootp::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            bootp::AuthInfo()
        }
    }
}

use proto_trait::ProtoKind; // keep internal to prevent impls
pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them

struct FileDownloadRequest&lt;P: ProtoKind&gt; {
    file_name: PathBuf,
    protocol: P,
}

// all common API parts go into a generic impl block
impl&lt;P: ProtoKind&gt; FileDownloadRequest&lt;P&gt; {
    fn file_path(&amp;self) -&gt; &amp;Path {
        &amp;self.file_name
    }

    fn auth_info(&amp;self) -&gt; P::AuthInfo {
        self.protocol.auth_info()
    }
}

// all protocol-specific impls go into their own block
impl FileDownloadRequest&lt;Nfs&gt; {
    fn mount_point(&amp;self) -&gt; &amp;Path {
        self.protocol.mount_point()
    }
}

fn main() {
    // your code here
}
</code></pre></pre>
<p>With this approach, if the user were to make a mistake and use the wrong
type;</p>
<pre><code class="language-rust ignore">fn main() {
    let mut socket = crate::bootp::listen()?;
    while let Some(request) = socket.next_request()? {
        match request.mount_point().as_ref()
            &quot;/secure&quot; =&gt; socket.send(&quot;Access denied&quot;),
            _ =&gt; {} // continue on...
        }
        // Rest of the code here
    }
}
</code></pre>
<p>They would get a syntax error. The type <code>FileDownloadRequest&lt;Bootp&gt;</code> does not
implement <code>mount_point()</code>, only the type <code>FileDownloadRequest&lt;Nfs&gt;</code> does. And
that is created by the NFS module, not the BOOTP module of course!</p>
<h2 id="advantages-16"><a class="header" href="#advantages-16">Advantages</a></h2>
<p>First, it allows fields that are common to multiple states to be de-duplicated.
By making the non-shared fields generic, they are implemented once.</p>
<p>Second, it makes the <code>impl</code> blocks easier to read, because they are broken down
by state. Methods common to all states are typed once in one block, and methods
unique to one state are in a separate block.</p>
<p>Both of these mean there are fewer lines of code, and they are better organized.</p>
<h2 id="disadvantages-17"><a class="header" href="#disadvantages-17">Disadvantages</a></h2>
<p>This currently increases the size of the binary, due to the way monomorphization
is implemented in the compiler. Hopefully the implementation will be able to
improve in the future.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<ul>
<li>
<p>If a type seems to need a &quot;split API&quot; due to construction or partial
initialization, consider the
<a href="functional/../patterns/creational/builder.html">Builder Pattern</a> instead.</p>
</li>
<li>
<p>If the API between types does not change -- only the behavior does -- then
the <a href="functional/../patterns/behavioural/strategy.html">Strategy Pattern</a> is better used
instead.</p>
</li>
</ul>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See also</a></h2>
<p>This pattern is used throughout the standard library:</p>
<ul>
<li><code>Vec&lt;u8&gt;</code> can be cast from a String, unlike every other type of <code>Vec&lt;T&gt;</code>.<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>They can also be cast into a binary heap, but only if they contain a type
that implements the <code>Ord</code> trait.<sup class="footnote-reference"><a href="#2">2</a></sup></li>
<li>The <code>to_string</code> method was specialized for <code>Cow</code> only of type <code>str</code>.<sup class="footnote-reference"><a href="#3">3</a></sup></li>
</ul>
<p>It is also used by several popular crates to allow API flexibility:</p>
<ul>
<li>
<p>The <code>embedded-hal</code> ecosystem used for embedded devices makes extensive use of
this pattern. For example, it allows statically verifying the configuration of
device registers used to control embedded pins. When a pin is put into a mode,
it returns a <code>Pin&lt;MODE&gt;</code> struct, whose generic determines the functions
usable in that mode, which are not on the <code>Pin</code> itself. <sup class="footnote-reference"><a href="#4">4</a></sup></p>
</li>
<li>
<p>The <code>hyper</code> HTTP client library uses this to expose rich APIs for different
pluggable requests. Clients with different connectors have different methods
on them as well as different trait implementations, while a core set of
methods apply to any connector. <sup class="footnote-reference"><a href="#5">5</a></sup></p>
</li>
<li>
<p>The &quot;type state&quot; pattern -- where an object gains and loses API based on an
internal state or invariant -- is implemented in Rust using the same basic
concept, and a slightly different technique. <sup class="footnote-reference"><a href="#6">6</a></sup></p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>See: <a href="https://doc.rust-lang.org/stable/src/std/ffi/c_str.rs.html#799-801">impl From&lt;CString&gt; for Vec&lt;u8&gt;</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>See: <a href="https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354">impl&lt;T&gt; From&lt;Vec&lt;T, Global&gt;&gt; for BinaryHeap&lt;T&gt;</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>See: <a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235-2240">impl&lt;'_&gt; ToString for Cow&lt;'_, str&gt;</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Example:
<a href="https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html">https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>See:
<a href="https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html">https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>See:
<a href="https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-pattern-itself/">The Case for the Type State Pattern</a>
and
<a href="https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index">Rusty Typestate Series (an extensive thesis)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h1>
<p>A collection of complementary helpful content</p>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=Pm_oO0N5B9k">Design Patterns in Rust</a> by
Nicholas Cameron at the PDRust (2016)</li>
<li><a href="https://www.youtube.com/watch?v=0zOg8_B71gE">Writing Idiomatic Libraries in Rust</a>
by Pascal Hertleif at RustFest (2017)</li>
<li><a href="https://www.youtube.com/watch?v=vqavdUGKeb4">Rust Programming Techniques</a> by
Nicholas Cameron at LinuxConfAu (2018)</li>
</ul>
<h2 id="books-online"><a class="header" href="#books-online">Books (Online)</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines">The Rust API Guidelines</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h1>
<h2 id="a-brief-overview-over-common-design-principles"><a class="header" href="#a-brief-overview-over-common-design-principles">A brief overview over common design principles</a></h2>
<hr />
<h2 id="a-hrefhttpsenwikipediaorgwikisolidsolida"><a class="header" href="#a-hrefhttpsenwikipediaorgwikisolidsolida"><a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle (SRP)</a>:
A class should only have a single responsibility, that is, only changes to
one part of the software's specification should be able to affect the
specification of the class.</li>
<li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open/Closed Principle (OCP)</a>:
&quot;Software entities ... should be open for extension, but closed for
modification.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle (LSP)</a>:
&quot;Objects in a program should be replaceable with instances of their subtypes
without altering the correctness of that program.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle (ISP)</a>:
&quot;Many client-specific interfaces are better than one general-purpose
interface.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle (DIP)</a>:
One should &quot;depend upon abstractions, [not] concretions.&quot;</li>
</ul>
<h2 id="a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa"><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don’t Repeat Yourself)</a></a></h2>
<p>&quot;Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system&quot;</p>
<h2 id="a-hrefhttpsenwikipediaorgwikikiss_principlekiss-principlea"><a class="header" href="#a-hrefhttpsenwikipediaorgwikikiss_principlekiss-principlea"><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a></a></h2>
<p>most systems work best if they are kept simple rather than made complicated;
therefore, simplicity should be a key goal in design, and unnecessary
complexity should be avoided</p>
<h2 id="a-hrefhttpsenwikipediaorgwikilaw_of_demeterlaw-of-demeter-loda"><a class="header" href="#a-hrefhttpsenwikipediaorgwikilaw_of_demeterlaw-of-demeter-loda"><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter (LoD)</a></a></h2>
<p>a given object should assume as little as possible about the structure or
properties of anything else (including its subcomponents), in accordance with
the principle of &quot;information hiding&quot;</p>
<h2 id="a-hrefhttpsenwikipediaorgwikidesign_by_contractdesign-by-contract-dbca"><a class="header" href="#a-hrefhttpsenwikipediaorgwikidesign_by_contractdesign-by-contract-dbca"><a href="https://en.wikipedia.org/wiki/Design_by_contract">Design by contract (DbC)</a></a></h2>
<p>software designers should define formal, precise and verifiable interface
specifications for software components, which extend the ordinary definition of
abstract data types with preconditions, postconditions and invariants</p>
<h2 id="a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programmingencapsulationa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programmingencapsulationa"><a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a></a></h2>
<p>bundling of data with the methods that operate on that data, or the restricting
of direct access to some of an object's components. Encapsulation is used to
hide the values or state of a structured data object inside a class, preventing
unauthorized parties' direct access to them.</p>
<h2 id="a-hrefhttpsenwikipediaorgwikicommande28093query_separationcommand-query-separationcqsa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikicommande28093query_separationcommand-query-separationcqsa"><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command-Query-Separation(CQS)</a></a></h2>
<p>“Functions should not produce abstract side effects...only commands
(procedures) will be permitted to produce side effects.” - Bertrand Meyer:
Object-Oriented Software Construction</p>
<h2 id="a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishmentprinciple-of-least-astonishment-polaa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishmentprinciple-of-least-astonishment-polaa"><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">Principle of least astonishment (POLA)</a></a></h2>
<p>a component of a system should behave in a way that most users will expect it
to behave. The behavior should not astonish or surprise users</p>
<h2 id="linguistic-modular-units"><a class="header" href="#linguistic-modular-units">Linguistic-Modular-Units</a></h2>
<p>“Modules must correspond to syntactic units in the language used.” - Bertrand
Meyer: Object-Oriented Software Construction</p>
<h2 id="self-documentation"><a class="header" href="#self-documentation">Self-Documentation</a></h2>
<p>“The designer of a module should strive to make all information about the
module part of the module itself.” - Bertrand Meyer: Object-Oriented Software
Construction</p>
<h2 id="uniform-access"><a class="header" href="#uniform-access">Uniform-Access</a></h2>
<p>“All services offered by a module should be available through a uniform
notation, which does not betray whether they are implemented through storage or
through computation.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="single-choice"><a class="header" href="#single-choice">Single-Choice</a></h2>
<p>“Whenever a software system must support a set of alternatives, one and only
one module in the system should know their exhaustive list.” - Bertrand Meyer:
Object-Oriented Software Construction</p>
<h2 id="persistence-closure"><a class="header" href="#persistence-closure">Persistence-Closure</a></h2>
<p>“Whenever a storage mechanism stores an object, it must store with it the
dependents of that object. Whenever a retrieval mechanism retrieves a
previously stored object, it must also retrieve any dependent of that object
that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented Software
Construction</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
