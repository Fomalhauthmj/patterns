<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Design Patterns</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A catalogue of Rust design patterns, anti-patterns and idioms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="idioms/index.html"><strong aria-hidden="true">2.</strong> 惯常做法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/coercion-arguments.html"><strong aria-hidden="true">2.1.</strong> 使用借用类型作为参数</a></li><li class="chapter-item expanded "><a href="idioms/concat-format.html"><strong aria-hidden="true">2.2.</strong> 用format!串联字符串</a></li><li class="chapter-item expanded "><a href="idioms/ctor.html"><strong aria-hidden="true">2.3.</strong> 构造器</a></li><li class="chapter-item expanded "><a href="idioms/default.html"><strong aria-hidden="true">2.4.</strong> Default Trait</a></li><li class="chapter-item expanded "><a href="idioms/deref.html"><strong aria-hidden="true">2.5.</strong> 集合是智能指针</a></li><li class="chapter-item expanded "><a href="idioms/dtor-finally.html"><strong aria-hidden="true">2.6.</strong> 析构器中的最终处理</a></li><li class="chapter-item expanded "><a href="idioms/mem-replace.html"><strong aria-hidden="true">2.7.</strong> mem::{take(), replace()}</a></li><li class="chapter-item expanded "><a href="idioms/on-stack-dyn-dispatch.html"><strong aria-hidden="true">2.8.</strong> 栈上动态分发</a></li><li class="chapter-item expanded "><a href="idioms/ffi/intro.html"><strong aria-hidden="true">2.9.</strong> 外部函数接口(FFI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="idioms/ffi/errors.html"><strong aria-hidden="true">2.9.1.</strong> 错误处理的惯常做法</a></li><li class="chapter-item expanded "><a href="idioms/ffi/accepting-strings.html"><strong aria-hidden="true">2.9.2.</strong> 接受字符串</a></li><li class="chapter-item expanded "><a href="idioms/ffi/passing-strings.html"><strong aria-hidden="true">2.9.3.</strong> 传递字符串</a></li></ol></li><li class="chapter-item expanded "><a href="idioms/option-iter.html"><strong aria-hidden="true">2.10.</strong> Option的迭代</a></li><li class="chapter-item expanded "><a href="idioms/pass-var-to-closure.html"><strong aria-hidden="true">2.11.</strong> 传递变量到闭包</a></li><li class="chapter-item expanded "><a href="idioms/priv-extend.html"><strong aria-hidden="true">2.12.</strong> 可扩展性</a></li><li class="chapter-item expanded "><a href="idioms/rustdoc-init.html"><strong aria-hidden="true">2.13.</strong> 简单的文档初始化</a></li><li class="chapter-item expanded "><a href="idioms/temporary-mutability.html"><strong aria-hidden="true">2.14.</strong> 临时可变性</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">3.</strong> 设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/behavioural/intro.html"><strong aria-hidden="true">3.1.</strong> 行为型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/behavioural/command.html"><strong aria-hidden="true">3.1.1.</strong> 命令</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/interpreter.html"><strong aria-hidden="true">3.1.2.</strong> 解释器</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/newtype.html"><strong aria-hidden="true">3.1.3.</strong> 新类型</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/RAII.html"><strong aria-hidden="true">3.1.4.</strong> RAII守护对象</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/strategy.html"><strong aria-hidden="true">3.1.5.</strong> 策略</a></li><li class="chapter-item expanded "><a href="patterns/behavioural/visitor.html"><strong aria-hidden="true">3.1.6.</strong> 访问器</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/creational/intro.html"><strong aria-hidden="true">3.2.</strong> 建造型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/creational/builder.html"><strong aria-hidden="true">3.2.1.</strong> 生成器</a></li><li class="chapter-item expanded "><a href="patterns/creational/fold.html"><strong aria-hidden="true">3.2.2.</strong> Fold</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/structural/intro.html"><strong aria-hidden="true">3.3.</strong> 结构型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/structural/compose-structs.html"><strong aria-hidden="true">3.3.1.</strong> 组合结构体</a></li><li class="chapter-item expanded "><a href="patterns/structural/small-crates.html"><strong aria-hidden="true">3.3.2.</strong> 倾向于较小的Crates</a></li><li class="chapter-item expanded "><a href="patterns/structural/unsafe-mods.html"><strong aria-hidden="true">3.3.3.</strong> 把不安全因素放在小模块中</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/ffi/intro.html"><strong aria-hidden="true">3.4.</strong> 外部函数接口(FFI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/ffi/export.html"><strong aria-hidden="true">3.4.1.</strong> 基于对象的API</a></li><li class="chapter-item expanded "><a href="patterns/ffi/wrappers.html"><strong aria-hidden="true">3.4.2.</strong> 类型合并</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="anti_patterns/index.html"><strong aria-hidden="true">4.</strong> 反面模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="anti_patterns/borrow_clone.html"><strong aria-hidden="true">4.1.</strong> 通过Clone来满足借用检查器</a></li><li class="chapter-item expanded "><a href="anti_patterns/deny-warnings.html"><strong aria-hidden="true">4.2.</strong> #[deny(warnings)]</a></li><li class="chapter-item expanded "><a href="anti_patterns/deref.html"><strong aria-hidden="true">4.3.</strong> 解引用多态性</a></li></ol></li><li class="chapter-item expanded "><a href="functional/index.html"><strong aria-hidden="true">5.</strong> 函数式编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functional/paradigms.html"><strong aria-hidden="true">5.1.</strong> 编程范式</a></li><li class="chapter-item expanded "><a href="functional/generics-type-classes.html"><strong aria-hidden="true">5.2.</strong> 作为类型类的泛型</a></li></ol></li><li class="chapter-item expanded "><a href="additional_resources/index.html"><strong aria-hidden="true">6.</strong> Additional Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="additional_resources/design-principles.html"><strong aria-hidden="true">6.1.</strong> 设计原则</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust Design Patterns</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/Fomalhauthmj/patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<h2 id="参与"><a class="header" href="#参与">参与</a></h2>
<p>如果你有兴趣为这本书做贡献，请查阅
<a href="https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md">贡献指南</a>.</p>
<h2 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h2>
<p>在开发程序时，我们必须解决许多问题。
一个程序可以被看作是一个问题的解决方案。
它也可以被看作是许多问题的解决方案的集合。
所有这些解决方案一起工作，以解决更大的问题。</p>
<h2 id="rust中的设计模式"><a class="header" href="#rust中的设计模式">Rust中的设计模式</a></h2>
<p>有许多问题具有相同的形式。
由于Rust不是面向对象的，设计模式与其他面向对象的编程语言不同。
虽然细节不同，但由于它们具有相同的形式，因此可以用相同的基本方法来解决：</p>
<ul>
<li><a href="./patterns/index.html">设计模式</a>是解决编写软件时常见问题的方法。</li>
<li><a href="./anti_patterns/index.html">反面模式</a>是解决这些相同的常见问题的方法。然而，在设计模式给我们带来好处的同时，反面模式却带来了更多的问题。</li>
<li><a href="./idioms/index.html">惯常做法</a>是编码时要遵循的准则。
它们是社区的社会规范。
你可以打破它们，但如果你这样做，你应该有一个好的理由。</li>
</ul>
<p>TODO：提到为什么Rust有点特别--函数式元素、类型系统、借用检查器</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="惯常做法"><a class="header" href="#惯常做法">惯常做法</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Programming_idiom">惯常做法</a>是常用的风格和模式，主要由一个社区商定。它们是准则。
编写习惯性代码可以让其他开发者了解正在发生的事情，因为他们熟悉它的形式。</p>
<p>计算机能够理解由编译器生成的机器代码。
因此，编程语言大多对开发者有利。
所以，既然我们有这个抽象层，为什么不好好利用它，让它变得简单？</p>
<p>记住<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS原则</a>：
&quot;保持简单，愚蠢&quot;。&quot;大多数系统如果保持简单而不是变得复杂，那么它们的工作效果最好；因此，简单应该是设计的一个关键目标，应该避免不必要的复杂性&quot;。</p>
<blockquote>
<p>代码是给人看的，而不是给电脑看的。</p>
</blockquote>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用借用类型作为参数"><a class="header" href="#使用借用类型作为参数">使用借用类型作为参数</a></h1>
<h2 id="描述"><a class="header" href="#描述">描述</a></h2>
<p>当你决定为一个函数参数使用哪种参数类型时，使用解引用强制转换的目标可以增加你代码的灵活性。
通过这种方式，该函数将接受更多的输入类型。</p>
<p>这并不限于可切片或胖指针类型。
事实上，你应该总是倾向于使用<strong>借用类型</strong>而不是<strong>借用所有类型</strong>。
例如<code>&amp;str</code>而不是<code>&amp;String</code>，<code>&amp;[T]</code>而不是<code>&amp;Vec&lt;T&gt;</code>，以及<code>&amp;T</code>而不是<code>&amp;Box&lt;T&gt;</code>。</p>
<p>使用借用类型，你可以避免已经提供一层间接性的所有类型上的多层间接。例如，<code>String</code>有一层间接，所以<code>&amp;String</code>会有两层间接。我们可以通过使用<code>&amp;str</code>来避免这种情况，并且让<code>&amp;String</code>在函数被调用时强制变成<code>&amp;str</code>。</p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<p>在这个例子中，我们将说明使用<code>&amp;String</code>作为函数参数与使用<code>&amp;str</code>的一些区别，但这些想法也适用于使用<code>&amp;Vec&lt;T&gt;</code>与使用<code>&amp;[T]</code>或使用<code>&amp;Box&lt;T&gt;</code>与使用<code>&amp;T</code>。</p>
<p>考虑这样一个例子，我们希望确定一个词是否包含三个连续的元音。我们不需要拥有字符串来确定这一点，所以我们将使用一个引用。</p>
<p>代码可能看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let ferris = &quot;Ferris&quot;.to_string();
    let curious = &quot;Curious&quot;.to_string();
    println!(&quot;{}: {}&quot;, ferris, three_vowels(&amp;ferris));
    println!(&quot;{}: {}&quot;, curious, three_vowels(&amp;curious));

    // This works fine, but the following two lines would fail:
    // println!(&quot;Ferris: {}&quot;, three_vowels(&quot;Ferris&quot;));
    // println!(&quot;Curious: {}&quot;, three_vowels(&quot;Curious&quot;));

}
</code></pre></pre>
<p>这样做没问题，因为我们传递的是一个<code>&amp;String</code>类型作为参数。
如果我们在最后两行取消注释，这个例子就会失败，因为<code>&amp;str</code>类型不会被强制变成<code>&amp;String</code>类型。我们可以通过简单地修改参数的类型来解决这个问题。</p>
<p>例如，如果我们把我们的函数声明改成：</p>
<pre><code class="language-rust  ignore">fn three_vowels(word: &amp;str) -&gt; bool {
</code></pre>
<p>那么这两个版本都会编译并打印相同的输出。</p>
<pre><code class="language-bash">Ferris: false
Curious: true
</code></pre>
<p>但等等，这还不是全部！这个话题还有更多的内容。
很可能你会对自己说：这并不重要，无论如何我都不会使用<code>&amp;'static str</code>作为输入（就像我们使用<code>&quot;Ferris&quot;</code>时那样）。
即使忽略这个特殊的例子，你仍然会发现使用<code>&amp;str</code>会比使用<code>&amp;String</code>更灵活。</p>
<p>现在我们来举个例子，有人给了我们一个句子，我们想确定句子中的任何一个词是否包含三个连续的元音。我们也许应该利用我们已经定义的函数，简单地输入句子中的每个词。</p>
<p>这个例子可能是这样的:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<p>使用我们声明的参数类型为<code>&amp;str</code>的函数运行这个例子将产生如下结果</p>
<pre><code class="language-bash">curious has three consecutive vowels!
</code></pre>
<p>然而，当我们的函数以参数类型<code>&amp;String</code>声明时，这个例子将无法运行。这是因为字符串切片是一个<code>&amp;str</code>，而不是一个<code>&amp;String</code>，后者需要一次内存分配来转换为<code>&amp;String</code>，这不是隐式的，而从<code>String</code>转换为<code>&amp;str</code>开销很低，而且是隐式的。</p>
<h2 id="参见"><a class="header" href="#参见">参见</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-coercions.html">Rust语言参考中关于类型强制转换</a></li>
<li>关于如何处理<code>String</code>和<code>&amp;str</code>的更多讨论见
<a href="https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html">blog系列（2015）</a>
by Herman J. Radtke III</li>
</ul>
<blockquote>
<p>Latest commit dca0dfd on Dec 16 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用format串联字符串"><a class="header" href="#用format串联字符串">用<code>format!</code>串联字符串</a></h1>
<h2 id="描述-1"><a class="header" href="#描述-1">描述</a></h2>
<p>可以在可变的<code>String</code>上使用<code>push</code>和<code>push_str</code>方法来建立字符串，或者使用其<code>+</code>操作符。
然而，使用<code>format!</code>往往更方便，特别是在有字面和非字面字符串混合的地方。</p>
<h2 id="例子-1"><a class="header" href="#例子-1">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hello(name: &amp;str) -&gt; String {
    // We could construct the result string manually.
    // let mut result = &quot;Hello &quot;.to_owned();
    // result.push_str(name);
    // result.push('!');
    // result

    // But using format! is better.
    format!(&quot;Hello {}!&quot;, name)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="优势"><a class="header" href="#优势">优势</a></h2>
<p>使用<code>format!</code>通常是组合字符串的最简洁和可读的方式。</p>
<h2 id="劣势"><a class="header" href="#劣势">劣势</a></h2>
<p>这通常不是组合字符串的最有效的方法——对一个可变的字符串进行一系列<code>push</code>的操作通常是最有效的（特别是当字符串已经被预先分配到预期的大小时）。</p>
<blockquote>
<p>Latest commit 5f1425d on 5 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构造器"><a class="header" href="#构造器">构造器</a></h1>
<h2 id="描述-2"><a class="header" href="#描述-2">描述</a></h2>
<p>Rust没有构造器作为语言构造。
相反，惯例是使用一个<a href="https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html#associated-functions">关联函数</a><code>new</code>来创建一个对象：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::new(42);
/// assert_eq!(42, s.value());
/// ```
pub struct Second {
    value: u64
}

impl Second {
    // Constructs a new instance of [`Second`].
    // Note this is an associated function - no self.
    pub fn new(value: u64) -&gt; Self {
        Self { value }
    }

    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="默认构造器"><a class="header" href="#默认构造器">默认构造器</a></h2>
<p>Rust通过<a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a>trait支持默认构造器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
pub struct Second {
    value: u64
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}

impl Default for Second {
    fn default() -&gt; Self {
        Self { value: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>如果所有类型的所有字段都实现了<code>Default</code>，也可以派生出<code>Default</code>，就像对<code>Second</code>那样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
#[derive(Default)]
pub struct Second {
    value: u64
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>**注意：**当为一个类型实现<code>Default</code>时，既不需要也不建议同时提供一个没有参数的相关函数<code>new</code>。</p>
<p>**提示：**实现或派生<code>Default</code>的好处是，你的类型现在可以用于需要实现<code>Default</code>的地方，最突出的是标准库中的任何<a href="https://doc.rust-lang.org/stable/std/?search=or_default"><code>*or_default</code>函数</a>。</p>
<h2 id="参见-1"><a class="header" href="#参见-1">参见</a></h2>
<ul>
<li>
<p><a href="idioms/default.html">default 惯常做法</a>对<code>Default</code>trait更深入的描述。</p>
</li>
<li>
<p><a href="idioms/../patterns/creational/builder.html">生成器模式</a>用于构建有多种配置的对象。</p>
</li>
</ul>
<blockquote>
<p>Latest commit fa8e722 on 22 Nov 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-trait"><a class="header" href="#default-trait"><code>Default</code> Trait</a></h1>
<h2 id="描述-3"><a class="header" href="#描述-3">描述</a></h2>
<p>Rust中的许多类型都有一个<a href="idioms/ctor.html">构造器</a>。然而，这是类型<em>特殊</em>的；Rust不能抽象出“所有对象都具有<code>new()</code>方法”。
为了允许这一点，我们设想了<a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a>trait，它可以用于容器和其他泛型（例如，见<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a>）。
值得注意的是，一些容器已经在适用的地方实现了它。</p>
<p>不仅像<code>Cow</code>、<code>Box</code>或<code>Arc</code>这样的单元素容器为所包含的<code>Default</code>类型实现了 <code>Default</code>，人们还可以自动为字段都实现了<code>Default</code>的结构体实现<code>#[derive(Default)]</code>，所以越多类型实现<code>Default</code>，它就越有用。</p>
<p>另一方面，构造器可以接受多个参数，而<code>default()</code>方法则不能。
甚至可以有多个名字不同的构造器，但每个类型只能有一个<code>Default</code>的实现。</p>
<h2 id="例子-2"><a class="header" href="#例子-2">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.
#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
        
    // partial initialization with default values, creates the same instance
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}
</code></pre></pre>
<h2 id="参见-2"><a class="header" href="#参见-2">参见</a></h2>
<ul>
<li><a href="idioms/ctor.html">构造器</a>惯常做法是另一种生成实例的方式，这些实例可能是也可能不是“默认”的。</li>
<li><a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> 文档 （向下滚动查看实现者列表）</li>
<li><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a></li>
<li><a href="https://crates.io/crates/derive-new/"><code>derive(new)</code></a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合是智能指针"><a class="header" href="#集合是智能指针">集合是智能指针</a></h1>
<h2 id="描述-4"><a class="header" href="#描述-4">描述</a></h2>
<p>使用<code>Deref</code>trait将集合视为智能指针，提供拥有
和借用的数据视图。</p>
<h2 id="例子-3"><a class="header" href="#例子-3">例子</a></h2>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Vec&lt;T&gt; {
    data: RawVec&lt;T&gt;,
    //..
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        //..
    }
}
</code></pre>
<p>一个<code>Vec&lt;T&gt;</code>是一个拥有<code>T</code>的集合，一个切片(<code>&amp;[T]</code>)是一个借用<code>T</code>的集合。
为<code>Vec</code>实现<code>Deref</code>允许从<code>&amp;Vec&lt;T&gt;</code>到<code>&amp;[T]</code>的隐式解引用，并在自动解引用搜索中包含这种关系。
你可能期望为<code>Vec</code>实现的大多数方法都是为切片实现的。</p>
<p>参见<code>String</code>和<code>&amp;str</code>。</p>
<h2 id="动机"><a class="header" href="#动机">动机</a></h2>
<p>所有权和借用是Rust语言的关键方面。
数据结构必须正确说明这些语义，以便提供良好的用户体验。
当实现一个拥有其数据的数据结构时，提供该数据的借用视图可以实现更灵活的API。</p>
<h2 id="优势-1"><a class="header" href="#优势-1">优势</a></h2>
<p>大多数方法只为借用视图实现，然后它们隐含地对拥有视图可用。</p>
<p>让客户端在借用或拥有数据的所有权之间做出选择。</p>
<h2 id="劣势-1"><a class="header" href="#劣势-1">劣势</a></h2>
<p>只有通过解引用才能使用的方法和trait在边界检查时不被考虑，所以使用这种模式的数据结构的泛型编程会变得很复杂（见<code>Borrow</code>和<code>AsRef</code>trait等）。</p>
<h2 id="讨论"><a class="header" href="#讨论">讨论</a></h2>
<p>智能指针和集合是类似的：一个智能指针指向一个对象，而一个集合指向许多对象。
从类型系统的角度来看，这两者之间没有什么区别。
如果访问每个数据的唯一途径是通过集合，并且集合负责删除数据（即使在共享所有权的情况下，某种借用视图可能是合适的），那么集合就拥有它的数据。
如果集合拥有它的数据，提供借用数据的视图通常是有用的，这样它就可以被多次引用了。</p>
<p>大多数智能指针（例如，<code>Foo&lt;T&gt;</code>）实现了<code>Deref&lt;Target=T&gt;</code>。
然而，集合通常会解引用到一个自定义的类型。
<code>[T]</code>和<code>str</code>有一些语言支持，但在一般情况下，这是没有必要的。
<code>Foo&lt;T&gt;</code>可以实现<code>Deref&lt;Target=Bar&lt;T&gt;</code>，其中<code>Bar</code>是一个动态大小的类型，<code>&amp;Bar&lt;T&gt;</code>是对<code>Foo&lt;T&gt;</code>中数据的借用视图。</p>
<p>通常，有序集合为<code>Range</code>实现<code>Index</code>，以提供分片语法。目标是借用视图。</p>
<h2 id="参见-3"><a class="header" href="#参见-3">参见</a></h2>
<p><a href="idioms/../anti_patterns/deref.html">反面模式：解引用多态性</a>.</p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code> trait 文档</a>.</p>
<blockquote>
<p>Latest commit 66d7e6c on 2 Oct 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="析构器中的最终处理"><a class="header" href="#析构器中的最终处理">析构器中的最终处理</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Rust没有提供与<code>finally</code>块相当的设施——无论函数如何退出都会被执行。
相反，一个对象的析构器可以被用来运行必须在退出前运行的代码。</p>
<h2 id="例子-4"><a class="header" href="#例子-4">例子</a></h2>
<pre><code class="language-rust ignore">fn bar() -&gt; Result&lt;(), ()&gt; {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&amp;mut self) {
            println!(&quot;exit&quot;);
        }
    }

    // The dtor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}
</code></pre>
<h2 id="动机-1"><a class="header" href="#动机-1">动机</a></h2>
<p>如果一个函数有多个返回点，那么在退出时执行代码就会变得困难和重复（从而容易产生错误）。
特别是在由于宏而隐式返回的情况下。
一个常见的情况是<code>?</code>操作符，如果结果是<code>Err</code>就返回，如果是<code>Ok</code>就继续。
<code>?</code>被用作异常处理机制，但不像Java（有<code>finally</code>），没有办法安排代码在正常和异常情况下运行。
发生Panic也会提前退出函数。</p>
<h2 id="优势-2"><a class="header" href="#优势-2">优势</a></h2>
<p>析构器中的代码将（几乎）一直运行——应对panic、提前返回等问题。</p>
<h2 id="劣势-2"><a class="header" href="#劣势-2">劣势</a></h2>
<p>事实上，并没有保证析构器一定会运行。
例如，如果在一个函数中存在一个无限循环，或者如果运行函数在退出前崩溃。
在已经发生panic的线程中，析构器也不会被运行。
因此，在绝对有必要进行最终处理的情况下，不能依靠析构器作为最终处理器。</p>
<p>这种模式引入了一些难以察觉的隐式代码。阅读一个函数时，没有明确指出退出时要运行哪些析构器。
这可能会使调试工作变得棘手。</p>
<p>要求对象和<code>Drop</code>实现若只是为了最终处理，会是很沉重的模板代码。</p>
<h2 id="讨论-1"><a class="header" href="#讨论-1">讨论</a></h2>
<p>关于如何准确地存储作为最终处理器的对象，有一些微妙的问题。
它必须被保存到函数结束，然后必须被销毁。
该对象必须始终是一个值或唯一拥有的指针（例如，<code>Box&lt;Foo&gt;</code>）。
如果使用一个共享的指针（如<code>Rc</code>），那么最终处理器可以在函数的生命周期之外保持生存。
出于类似的原因，最终处理器不应该被移动或返回。</p>
<p>最终处理器必须被分配到一个变量中，否则它将被立即销毁，而不是当它超出作用域时。
如果该变量只作为最终处理器使用，其名称必须以<code>_</code>开头，否则编译器会警告说最终处理器从未被使用。
然而，不要调用没有后缀的变量<code>_</code>——在这种情况下，它将被立即销毁。</p>
<p>在Rust中，当一个对象超出作用域时，会运行析构器。
这发生在我们到达块的末尾，有一个早期返回，或者程序发生panic。
当发生panic时，Rust会展开堆栈，为每个堆栈帧中的每个对象运行析构器。
因此，即使panic发生在被调用的函数中，析构器也会被调用。</p>
<p>如果在展开的过程中一个析构器发生panic，那么就没有好的行动可以采取，所以Rust会立即中止线程，而不再运行其他的析构器。
这意味着析构器不能绝对保证运行。
这也意味着你必须在你的析构器中格外小心，不要panic，因为它可能会让资源处于一个意想不到的状态。</p>
<h2 id="参见-4"><a class="header" href="#参见-4">参见</a></h2>
<p><a href="idioms/../patterns/behavioural/RAII.html">RAII守护对象</a></p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在发生改变的枚举中使用memtake_-replace_来保留所有值"><a class="header" href="#在发生改变的枚举中使用memtake_-replace_来保留所有值">在发生改变的枚举中使用<code>mem::{take(_), replace(_)}</code>来保留所有值</a></h1>
<h2 id="描述-5"><a class="header" href="#描述-5">描述</a></h2>
<p>假定我们有一个<code>&amp;mut MyEnum</code>，它有（至少）两个变体，
<code>A { name: String, x: u8 }</code>和<code>B { name: String }</code>。
现在我们想如果<code>x</code>为零，把<code>MyEnum::A</code>改成<code>B</code>，同时保持<code>MyEnum::B</code>不变。</p>
<p>我们可以在不克隆<code>name</code>的情况下做到这一点。</p>
<h2 id="例子-5"><a class="header" href="#例子-5">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String }
}

fn a_to_b(e: &amp;mut MyEnum) {
    if let MyEnum::A { name, x: 0 } = e {
        // this takes out our `name` and put in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`).
        *e = MyEnum::B { name: mem::take(name) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这也适用于更多的变体：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B { name: mem::take(name) },
        B { name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机-2"><a class="header" href="#动机-2">动机</a></h2>
<p>在处理枚举时，我们可能想在原地改变一个枚举值，也许是改变成另一个变体。 
为了通过借用检查器，这通常分两个阶段进行。
在第一阶段，我们观察现有值，看看它的各个部分，以决定下一步该做什么
在第二阶段，我们可以有条件地改变该值（如上面的例子）。</p>
<p>借用检查器不允许我们取走枚举类型的<code>name</code>（因为<em>something</em>必须存在。）
尽管我们可以<code>.clone()``name</code>然后将克隆值放入<code>MyEnum::B</code>中，但这就是反面模式<a href="idioms/../anti_patterns/borrow_clone.html">通过Clone来满足借用检查器</a> 的一个例子了。 
无论如何，我们可以通过只用一个可变借用来改变<code>e</code>，进而避免额外的内存分配。</p>
<p><code>mem::take</code>可以换掉这个值，用它的默认值代替，并返回之前的值。
对于<code>String</code>，默认值是一个空的<code>String</code>，不需要分配内存。
最终，我们得到了原来的<code>name</code><em>作为一个所有值</em>。然后我们可以把它包在另一个枚举中。</p>
<p><strong>注意：</strong> <code>mem::replace</code>非常相似，但允许我们指定用什么来替换值。
<code>mem::take</code>等价于<code>mem::replace(name, String::new())</code>.</p>
<p>但是请注意，如果我们使用一个<code>Option</code>，并想用一个<code>None</code>来替换它的值，<code>Option</code>的<code>take()</code>方法提供了一个更短和更习惯的替代方法。</p>
<h2 id="优势-3"><a class="header" href="#优势-3">优势</a></h2>
<p>没有内存分配。</p>
<h2 id="劣势-3"><a class="header" href="#劣势-3">劣势</a></h2>
<p>表达比较啰嗦，经常搞错会让你讨厌借用检查器。 
编译器可能无法优化掉双重存储，从而导致性能下降，这与你在不安全语言中的做法是不同的。</p>
<p>此外，你拿走的类型需要实现<a href="idioms/./default.html"><code>Default</code>trait</a>。 
如果你正在使用的类型没有实现，你可以使用<code>mem::replace</code>代替。</p>
<h2 id="讨论-2"><a class="header" href="#讨论-2">讨论</a></h2>
<p>这种模式只在Rust中才有意义。
在有垃圾回收的语言中，默认取值的引用（GC会跟踪引用），而在其他低级语言如C语言中，可以简单地别名指针，并在以后修复。</p>
<p>然而，在Rust中，我们必须多做一点工作才能做到这一点。一个所有值可能只有一个所有者，所以要把它取出来，我们需要把一些东西放回去。</p>
<h2 id="参见-5"><a class="header" href="#参见-5">参见</a></h2>
<p>在特定情况下，可以去除<a href="idioms/../anti_patterns/borrow_clone.html">通过Clone来满足借用检查器</a>的反面模式。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="栈上动态分发"><a class="header" href="#栈上动态分发">栈上动态分发</a></h1>
<h2 id="描述-6"><a class="header" href="#描述-6">描述</a></h2>
<p>我们可以对多个值进行动态分发，然而，要做到这一点，我们需要声明多个变量来绑定不同类型的对象。
为了根据需要延长生命周期，我们可以使用延迟条件初始化，如下所示：</p>
<h2 id="例子-6"><a class="header" href="#例子-6">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use std::io;
use std::fs;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let arg = &quot;-&quot;;

    // These must live longer than `readable`, and thus are declared first:
    let (mut stdin_read, mut file_read);

    // We need to ascribe the type to get dynamic dispatch.
    let readable: &amp;mut dyn io::Read = if arg == &quot;-&quot; {
        stdin_read = io::stdin();
        &amp;mut stdin_read
    } else {
        file_read = fs::File::open(arg)?;
        &amp;mut file_read
    };

    // Read from `readable` here.

    Ok(())
}
</code></pre></pre>
<h2 id="动机-3"><a class="header" href="#动机-3">动机</a></h2>
<p>Rust默认会对代码进行单态处理。这意味着每一种类型的代码都会被生成一个副本，并被独立优化。
虽然这允许在热点路径上产生非常快的代码，但它也会在性能不重要的地方使代码变得臃肿，从而耗费编译时间和缓存使用量。</p>
<p>幸运的是，Rust允许我们使用动态分发，但我们必须明确要求它。</p>
<h2 id="优势-4"><a class="header" href="#优势-4">优势</a></h2>
<p>我们不需要在堆上分配任何东西。
我们也不需要初始化一些我们以后不会用到的东西，也不需要把下面的整个代码单一化，以便<code>File</code>或<code>Stdin</code>一起工作。</p>
<h2 id="劣势-4"><a class="header" href="#劣势-4">劣势</a></h2>
<p>该代码需要比基于<code>Box</code>的版本有更多的移动语义部分。</p>
<pre><code class="language-rust ignore">// We still need to ascribe the type for dynamic dispatch.
let readable: Box&lt;dyn io::Read&gt; = if arg == &quot;-&quot; {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// Read from `readable` here.
</code></pre>
<h2 id="讨论-3"><a class="header" href="#讨论-3">讨论</a></h2>
<p>Rust新手通常会了解到，Rust要求所有变量在<em>使用前</em>被初始化，所以很容易忽略这样一个事实，即<em>未使用的</em>变量很可能是未初始化的。
Rust非常努力地确保这一点，而且只有初始化过的值在其作用域的末端被丢弃。</p>
<p>这个例子符合Rust对我们的所有约束：</p>
<ul>
<li>所有的变量在使用（本例中为借用）之前都被初始化。</li>
<li>每个变量只持有单一类型的值。在我们的例子中，<code>stdin</code>是<code>Stdin</code>类型，<code>file</code>是<code>File</code>类型，<code>readable</code>是<code>&amp;mut dyn Read</code>类型。</li>
<li>每个被借用值的生命周期都比它的所有借用引用要久。</li>
</ul>
<h2 id="参见-6"><a class="header" href="#参见-6">参见</a></h2>
<ul>
<li><a href="idioms/dtor-finally.html">析构器中的最终处理</a>和<a href="idioms/../patterns/behavioural/RAII.html">RAII守护对象</a>可以从对生命周期的严格控制中获益。</li>
<li>对于条件填充的<code>Option&lt;T&gt;</code>的（可变）引用，可以直接初始化一个<code>Option&lt;T&gt;</code>，并使用其<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref"><code>.as_ref()</code></a>方法来获取其引用。</li>
</ul>
<blockquote>
<p>Latest commit a152399 on 21 Apr 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-惯常做法"><a class="header" href="#ffi-惯常做法">FFI 惯常做法</a></h1>
<p>编写FFI代码本身就是一个完整的课程。
然而，这里有几个惯常做法可以作为指导，避免没有经验的用户在<code>unsafe</code>Rust中踩坑。</p>
<p>本节包含了在开发FFI时可能有用的惯常做法。</p>
<ol>
<li>
<p><a href="idioms/ffi/./errors.html">错误处理的惯常做法</a>——用整数值和哨兵返回值处理错误（如<code>NULL</code>指针）。</p>
</li>
<li>
<p><a href="idioms/ffi/./accepting-strings.html">接受字符串</a>，使用最少的不安全代码。</p>
</li>
<li>
<p><a href="idioms/ffi/./passing-strings.html">传递字符串</a>到FFI函数。</p>
</li>
</ol>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi中的错误处理"><a class="header" href="#ffi中的错误处理">FFI中的错误处理</a></h1>
<h2 id="描述-7"><a class="header" href="#描述-7">描述</a></h2>
<p>在C语言等外部语言中，错误是由返回码来表示的。
然而，Rust的类型系统允许通过一个完整的类型来捕获和传播更丰富的错误信息。</p>
<p>这个最佳实践展示了不同种类的错误代码，以及如何以一种可用的方式暴露它们：</p>
<ol>
<li>简单枚举应该被转换为整数，并作为代码返回。</li>
<li>结构化的枚举应该被转换为整数代码，并有一个字符串错误消息作为细节。</li>
<li>自定义错误类型应该变得”透明“，用C表示。</li>
</ol>
<h2 id="代码示例"><a class="header" href="#代码示例">代码示例</a></h2>
<h3 id="简单枚举"><a class="header" href="#简单枚举">简单枚举</a></h3>
<pre><code class="language-rust ignore">enum DatabaseError {
    IsReadOnly = 1, // user attempted a write operation
    IOError = 2, // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}
</code></pre>
<h3 id="结构化枚举"><a class="header" href="#结构化枚举">结构化枚举</a></h3>
<pre><code class="language-rust ignore">pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;

    #[no_mangle]
    pub extern &quot;C&quot; fn db_error_description(
        e: *const DatabaseError
        ) -&gt; *mut libc::c_char {

        let error: &amp;DatabaseError = unsafe {
            // SAFETY: pointer lifetime is greater than the current stack frame
            &amp;*e
        };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!(&quot;cannot write to read-only database&quot;);
            }
            DatabaseError::IOError(e) =&gt; {
                format!(&quot;I/O Error: {}&quot;, e);
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!(&quot;File corrupted, run repair: {}&quot;, &amp;s);
            }
        };

        let c_error = unsafe {
            // SAFETY: copying error_str to an allocated buffer with a NUL
            // character at the end
            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as *mut _;

            if malloc.is_null() {
                return std::ptr::null_mut();
            }

            let src = error_str.as_bytes().as_ptr();

            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());

            std::ptr::write(malloc.add(error_str.len()), 0);

            malloc as *mut libc::c_char
        };

        c_error
    }
}
</code></pre>
<h3 id="自定义错误类型"><a class="header" href="#自定义错误类型">自定义错误类型</a></h3>
<pre><code class="language-rust ignore">struct ParseError {
    expected: char,
    line: u32,
    ch: u16
}

impl ParseError { /* ... */ }

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}
</code></pre>
<h2 id="优势-5"><a class="header" href="#优势-5">优势</a></h2>
<p>这就保证了外部语言可以清楚地获得错误信息，同时完全不影响Rust代码的API。</p>
<h2 id="劣势-5"><a class="header" href="#劣势-5">劣势</a></h2>
<p>这是很大的工作量，有些类型可能不容易被转换为C语言中的表示。</p>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接受字符串"><a class="header" href="#接受字符串">接受字符串</a></h1>
<h2 id="描述-8"><a class="header" href="#描述-8">描述</a></h2>
<p>当FFI通过指针接受字符串时，应该遵循两个原则：</p>
<ol>
<li>保持外部字符串是“借用”的，而不是直接复制它们。</li>
<li>尽量减少从C风格字符串转换到原生Rust字符串时涉及的复杂性和<code>unsafe</code>代码量。</li>
</ol>
<h2 id="动机-4"><a class="header" href="#动机-4">动机</a></h2>
<p>C语言中使用的字符串与Rust语言中使用的字符串有不同的行为：</p>
<ul>
<li>C语言的字符串是无终止的，而Rust语言的字符串会存储其长度。</li>
<li>C语言的字符串可以包含任何任意的非零字节，而Rust的字符串必须是UTF-8。</li>
<li>C语言的字符串使用<code>unsafe</code>的指针操作来访问和操作，而与Rust字符串的交互是通过安全方法进行的。</li>
</ul>
<p>Rust标准库提供了与Rust的<code>String</code>和<code>&amp;str</code>相对应的C语言等价表示，称为<code>CString</code>和<code>&amp;CStr</code>，这使得我们可以避免在C语言字符串和Rust字符串之间转换的复杂性和<code>unsafe</code>代码。</p>
<p><code>&amp;CStr</code>类型还允许我们使用借用数据，这意味着在Rust和C之间传递字符串是一个零成本的操作。</p>
<h2 id="代码示例-1"><a class="header" href="#代码示例-1">代码示例</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    /// Log a message at the specified level.
    ///
    /// # Safety
    ///
    /// It is the caller's guarantee to ensure `msg`:
    ///
    /// - is not a null pointer
    /// - points to valid, initialized data
    /// - points to memory ending in a null byte
    /// - won't be mutated for the duration of this function call
    #[no_mangle]
    pub unsafe extern &quot;C&quot; fn mylib_log(
        msg: *const libc::c_char,
        level: libc::c_int
    ) {
        let level: crate::LogLevel = match level { /* ... */ };

        // SAFETY: The caller has already guaranteed this is okay (see the
        // `# Safety` section of the doc-comment).
        let msg_str: &amp;str = match std::ffi::CStr::from_ptr(msg).to_str() {
            Ok(s) =&gt; s,
            Err(e) =&gt; {
                crate::log_error(&quot;FFI string conversion failed&quot;);
                return;
            }
        };

        crate::log(msg_str, level);
    }
}
</code></pre>
<h2 id="优势-6"><a class="header" href="#优势-6">优势</a></h2>
<p>这个例子的编写是为了确保：</p>
<ol>
<li><code>unsafe</code>块尽可能小。</li>
<li>具有“未跟踪”的生命周期的指针成为“跟踪”的共享引用。</li>
</ol>
<p>考虑一个替代方案，即实际复制字符串：</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub extern &quot;C&quot; fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        // DO NOT USE THIS CODE.
        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.

        let level: crate::LogLevel = match level { /* ... */ };

        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */
            libc::strlen(msg)
        };

        let mut msg_data = Vec::with_capacity(msg_len + 1);

        let msg_cstr: std::ffi::CString = unsafe {
            // SAFETY: copying from a foreign pointer expected to live
            // for the entire stack frame into owned memory
            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);

            msg_data.set_len(msg_len + 1);

            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()
        }

        let msg_str: String = unsafe {
            match msg_cstr.into_string() {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    crate::log_error(&quot;FFI string conversion failed&quot;);
                    return;
                }
            }
        };

        crate::log(&amp;msg_str, level);
    }
}
</code></pre>
<p>这个版本的代码在两个方面比原版逊色：</p>
<ol>
<li>有更多的<code>unsafe</code>代码，更重要的是，它必须坚持更多的不变量。</li>
<li>由于需要大量的算术，这个版本有一个错误，会导致Rust的<code>undefined behaviour</code>。</li>
</ol>
<p>这里的错误是一个简单的指针运算错误：字符串所有的<code>msg_len</code>字节被复制了。
但是，结尾的<code>NUL</code>终止符没有被复制。</p>
<p>然后，Vector的大小被<em>设置</em>为<em>zero padded string</em>的长度——而不是<em>调整大小</em>到它，即可能会在最后添加一个零。
结果是，Vector中的最后一个字节是未初始化的内存。
当<code>CString</code>在块的底部被创建时，它对Vector的读取将导致<code>undefined behaviour</code>！</p>
<p>像许多这样的问题一样，这将是一个很难追踪的问题。
有时它会因为字符串不是<code>UTF-8</code>而panic，有时它会在字符串的末尾放一个奇怪的字符，有时它会完全崩溃。</p>
<h2 id="劣势-6"><a class="header" href="#劣势-6">劣势</a></h2>
<p>没有？</p>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="传递字符串"><a class="header" href="#传递字符串">传递字符串</a></h1>
<h2 id="描述-9"><a class="header" href="#描述-9">描述</a></h2>
<p>当向FFI函数传递字符串时，应该遵循四个原则：</p>
<ol>
<li>使拥有的字符串的生命周期尽可能长。</li>
<li>在转换过程中尽量减少<code>unsafe</code>代码。</li>
<li>如果C代码可以修改字符串数据，使用<code>Vec</code>而不是<code>CString</code>。</li>
<li>除非外部函数API要求，否则字符串的所有权不应该转移给被调用者。</li>
</ol>
<h2 id="动机-5"><a class="header" href="#动机-5">动机</a></h2>
<p>Rust内置了对C风格字符串的支持，有<code>CString</code>和<code>CStr</code>类型。
然而，对于从Rust函数中发送字符串到外部函数调用，我们可以采取不同的方法。</p>
<p>最好的做法很简单：用<code>CString</code>的方式来减少<code>unsafe</code>的代码。
然而，次要的注意事项是，<em>对象必须活得足够长</em>，这意味着生命周期应该最大化。
此外，文档解释说，<code>CString</code>进行&quot;round-tripping&quot;修改是未定义行为，所以在这种情况下需要额外的工作。</p>
<h2 id="代码示例-2"><a class="header" href="#代码示例-2">代码示例</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    extern &quot;C&quot; {
        fn seterr(message: *const libc::c_char);
        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -&gt; libc::c_int;
    }

    fn report_error_to_ffi&lt;S: Into&lt;String&gt;&gt;(
        err: S
    ) -&gt; Result&lt;(), std::ffi::NulError&gt;{
        let c_err = std::ffi::CString::new(err.into())?;

        unsafe {
            // SAFETY: calling an FFI whose documentation says the pointer is
            // const, so no modification should occur
            seterr(c_err.as_ptr());
        }

        Ok(())
        // The lifetime of c_err continues until here
    }

    fn get_error_from_ffi() -&gt; Result&lt;String, std::ffi::IntoStringError&gt; {
        let mut buffer = vec![0u8; 1024];
        unsafe {
            // SAFETY: calling an FFI whose documentation implies
            // that the input need only live as long as the call
            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();

            buffer.truncate(written + 1);
        }

        std::ffi::CString::new(buffer).unwrap().into_string()
    }
}
</code></pre>
<h2 id="优势-7"><a class="header" href="#优势-7">优势</a></h2>
<p>这个例子的编写方式是为了确保：</p>
<ol>
<li><code>unsafe</code>块尽可能小。</li>
<li><code>CString</code>存活得足够久。</li>
<li>类型转换的错误被尽可能传播。</li>
</ol>
<p>一个常见的错误（常见到在文档中）是不在第一个块中使用变量：</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    fn report_error&lt;S: Into&lt;String&gt;&gt;(err: S) -&gt; Result&lt;(), std::ffi::NulError&gt; {
        unsafe {
            // SAFETY: whoops, this contains a dangling pointer!
            seterr(std::ffi::CString::new(err.into())?.as_ptr());
        }
        Ok(())
    }
}
</code></pre>
<p>这段代码将导致一个悬垂指针，因为<code>CString</code>的生命周期并没有因为指针的创建而延长，这与创建引用的情况不同。</p>
<p>另一个经常提出的问题是，初始化1k个零的向量是“慢”的。
然而，最近的Rust版本实际上将这个特殊的宏优化为对<code>zmalloc</code>的调用，这意味着它的速度和操作系统返回零内存的能力一样快（这相当快）。</p>
<h2 id="劣势-7"><a class="header" href="#劣势-7">劣势</a></h2>
<p>没有？</p>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option的迭代"><a class="header" href="#option的迭代"><code>Option</code>的迭代</a></h1>
<h2 id="描述-10"><a class="header" href="#描述-10">描述</a></h2>
<p><code>Option</code>可以被看作是一个包含零或一个元素的容器。
特别是，它实现了<code>IntoIterator</code>trait，因此可以用于需要这种类型的通用代码。</p>
<h2 id="例子-7"><a class="header" href="#例子-7">例子</a></h2>
<p>由于<code>Option</code>实现了<code>IntoIterator</code>，它可以作为<a href="https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend"><code>.extend()</code></a>的一个参数：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let mut logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

logicians.extend(turing);

// equivalent to
if let Some(turing_inner) = turing {
    logicians.push(turing_inner);
}
<span class="boring">}
</span></code></pre></pre>
<p>如果你需要把一个<code>Option</code>粘到现有迭代器的末尾，你可以把它传递给<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some(&quot;Turing&quot;);
let logicians = vec![&quot;Curry&quot;, &quot;Kleene&quot;, &quot;Markov&quot;];

for logician in logicians.iter().chain(turing.iter()) {
    println!(&quot;{} is a logician&quot;, logician);
}
<span class="boring">}
</span></code></pre></pre>
<p>注意，如果<code>Option</code>总是<code>Some</code>，那么在元素上使用<a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a>更常见。</p>
<p>另外，由于<code>Option</code>实现了<code>IntoIterator</code>，所以可以使用<code>for</code>循环对其进行迭代。
这相当于用<code>if let Some(..)</code>来匹配它，在大多数情况下，你应该选择后者。</p>
<h2 id="参见-7"><a class="header" href="#参见-7">参见</a></h2>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a>是一个迭代器，正好产生一个元素。
它是<code>Some(foo).into_iter()</code>的一个更易读的替代品。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"><code>Iterator::filter_map</code></a>是<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>Iterator::flat_map</code></a>的一个版本，专门用于返回<code>Option</code>的映射函数。</p>
</li>
<li>
<p><a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a>crate提供了将<code>Option</code>转换为零或单个元素切片的函数。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code>文档</a></p>
</li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="传递变量到闭包"><a class="header" href="#传递变量到闭包">传递变量到闭包</a></h1>
<h2 id="描述-11"><a class="header" href="#描述-11">描述</a></h2>
<p>默认情况下，闭包通过借用来捕获其环境。或者你可以使用 <code>move</code>-closure 来移动整个环境。
然而，你往往只想把一些变量转移到闭包中，给它一些数据的拷贝，通过引用传递，或者执行一些其他的转换。</p>
<p>为此，在单独的作用域中使用变量重绑定。</p>
<h2 id="例子-8"><a class="header" href="#例子-8">例子</a></h2>
<p>使用</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="优势-8"><a class="header" href="#优势-8">优势</a></h2>
<p>复制的数据和闭包定义在一起，所以它们的目的更明确，而且即使它们没有被闭包消耗，也会被立即丢弃。</p>
<p>无论数据是被复制还是被移动，闭包都使用与周围代码相同的变量名。</p>
<h2 id="劣势-8"><a class="header" href="#劣势-8">劣势</a></h2>
<p>闭包体的额外缩进。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non_exhaustive和私有字段的可扩展性"><a class="header" href="#non_exhaustive和私有字段的可扩展性"><code>#[non_exhaustive]</code>和私有字段的可扩展性</a></h1>
<h2 id="描述-12"><a class="header" href="#描述-12">描述</a></h2>
<p>在一小部分情况下，库作者可能想在不破坏后向兼容性的情况下，为公共结构体添加公共字段或为枚举添加新的变体。</p>
<p>Rust为这个问题提供了两种解决方案：</p>
<ul>
<li>
<p>在<code>struct</code>，<code>enum</code>和<code>enum</code>变体上使用<code>#[non_exhaustive]</code>。
关于所有可以使用<code>#[non_exhaustive]</code>的地方的详细文档，见<a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute">文档</a>。</p>
</li>
<li>
<p>你可以向结构体添加一个私有字段，以防止它被直接实例化或与之匹配（见备选方案）。</p>
</li>
</ul>
<h2 id="例子-9"><a class="header" href="#例子-9">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    // Public struct.
    #[non_exhaustive]
    pub struct S {
        pub foo: i32,
    }
    
    #[non_exhaustive]
    pub enum AdmitMoreVariants {
        VariantA,
        VariantB,
        #[non_exhaustive]
        VariantC { a: String }
    }
}

fn print_matched_variants(s: a::S) {
    // Because S is `#[non_exhaustive]`, it cannot be named here and
    // we must use `..` in the pattern.
    let a::S { foo: _, ..} = s;
    
    let some_enum = a::AdmitMoreVariants::VariantA;
    match some_enum {
        a::AdmitMoreVariants::VariantA =&gt; println!(&quot;it's an A&quot;),
        a::AdmitMoreVariants::VariantB =&gt; println!(&quot;it's a b&quot;),

        // .. required because this variant is non-exhaustive as well
        a::AdmitMoreVariants::VariantC { a, .. } =&gt; println!(&quot;it's a c&quot;),

        // The wildcard match is required because more variants may be
        // added in the future
        _ =&gt; println!(&quot;it's a new variant&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="备选方案结构体的private-fields"><a class="header" href="#备选方案结构体的private-fields">备选方案：结构体的<code>Private fields</code></a></h2>
<p><code>#[non_exhaustive]</code>只适用于跨crate边界的情况。
在一个crate内，可以使用私有字段方法。</p>
<p>在结构体中添加字段基本上是一个向后兼容的变化。
然而，如果客户端使用某种模式来解构结构体实例，他们可能会命名结构体中的所有字段，而添加新字段会破坏这种模式。
客户端可以命名一些字段并在模式中使用<code>..</code>，在这种情况下，添加另一个字段是向后兼容的。
将结构体中的至少一个字段设置为私有，迫使客户端使用后一种形式的模式，确保结构体是面向未来的。</p>
<p>这种方法的缺点是，你可能需要在结构体中添加一个原本不需要的字段。
你可以使用<code>()</code>类型，这样就没有运行时的开销，并在字段名前加上<code>_</code>，以避免未使用字段的警告。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    pub a: i32,
    // Because `b` is private, you cannot match on `S` without using `..` and `S`
    //  cannot be directly instantiated or matched against
    _b: ()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="讨论-4"><a class="header" href="#讨论-4">讨论</a></h2>
<p>在<code>struct</code>上，<code>#[non_exhaustive]</code>允许以向后兼容的方式添加额外字段。
它也会阻止客户端使用结构体的构造器，即使所有字段都是公开的。
这可能很有帮助，但值得考虑的是，你是否<em>希望</em>额外的字段被客户端发现是一个编译器错误，而不是默默地不被发现。</p>
<p><code>#[non_exhaustive]</code>也可以应用于枚举的变体。
<code>#[non_exhaustive]</code>变体的行为与<code>#[non_exhaustive]</code>结构体的行为相同。</p>
<p>慎重使用：在添加字段或变体时，增加主版本通常是更好的选择。
<code>#[non_exhaustive]</code>可能适用于这样的情况：你正在为一个可能与你的库不同步变化的外部资源建模，但这不是一个通用工具。</p>
<h3 id="劣势-9"><a class="header" href="#劣势-9">劣势</a></h3>
<p><code>#[non_exhaustive]</code>会使你的代码使用起来更不符合人体工程学，特别是在被迫处理未知的枚举变体的时候。
它应该只在需要这些改变，却又<strong>不需要</strong>递增主版本时使用。</p>
<p>当<code>#[non_exhaustive]</code>被应用于<code>enum</code>时，它迫使客户端处理通配符变体。
如果在这种情况下没有采取合理的行动，这可能会导致丑陋的代码和只在极其罕见情况下才会执行的代码路径。
如果客户端在这种情况下决定<code>panic!()</code>，那么在编译时暴露这个错误可能会更好。
事实上，<code>#[non_exhaustive]</code>迫使客户端处理&quot;Something else&quot;的情况；在这种情况下，很少有明智的行动可以采取。</p>
<h2 id="参见-8"><a class="header" href="#参见-8">参见</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md">为枚举和结构体引入#[non_exhaustive]属性的RFC</a></li>
</ul>
<blockquote>
<p>Latest commit 567a1f1 on 1 Sep 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单的文档初始化"><a class="header" href="#简单的文档初始化">简单的文档初始化</a></h1>
<h2 id="描述-13"><a class="header" href="#描述-13">描述</a></h2>
<p>如果一个结构体需要花费大量精力来初始化，那么在编写文档时，用一个将结构体作为参数的辅助函数来包装你的例子可能会更快。</p>
<h2 id="动机-6"><a class="header" href="#动机-6">动机</a></h2>
<p>有时，一个结构体有多个或复杂的参数和几个方法。
这些方法中的每一个都应该有例子。</p>
<p>例如：</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```no_run
    /// # // Boilerplate are required to get an example working.
    /// # let stream = TcpStream::connect(&quot;127.0.0.1:34254&quot;);
    /// # let connection = Connection { name: &quot;foo&quot;.to_owned(), stream };
    /// # let request = Request::new(&quot;RequestId&quot;, RequestType::Get, &quot;payload&quot;);
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// ```
    fn send_request(&amp;self, request: Request) -&gt; Result&lt;Status, SendErr&gt; {
        // ...
    }

    /// Oh no, all that boilerplate needs to be repeated here!
    fn check_status(&amp;self) -&gt; Status {
        // ...
    }
}
</code></pre>
<h2 id="例子-10"><a class="header" href="#例子-10">例子</a></h2>
<p>与其输入所有这些模板代码来创建一个<code>Connection</code>和<code>Request</code>，不如直接创建一个将它们作为参数的包装辅助函数：</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```
    /// # fn call_send(connection: Connection, request: Request) {
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// # }
    /// ```
    fn send_request(&amp;self, request: Request) {
        // ...
    }
}
</code></pre>
<p>**注意：**在上面的例子中，<code>assert!(response.is_ok());</code>这一行在测试时不会实际运行，因为它是在一个从未被调用的函数中。</p>
<h2 id="优势-9"><a class="header" href="#优势-9">优势</a></h2>
<p>更简洁，避免了例子中的重复代码。</p>
<h2 id="劣势-10"><a class="header" href="#劣势-10">劣势</a></h2>
<p>由于例子是在一个函数中，代码将不会被测试。
尽管在运行<code>cargo test</code>时，它仍然会被检查，以确保它能编译。
所以当你需要<code>no_run</code>时，这种模式是最有用的。有了这个，你不需要添加<code>no_run</code>。</p>
<h2 id="讨论-5"><a class="header" href="#讨论-5">讨论</a></h2>
<p>如果不需要断言，这种模式很好用。</p>
<p>如果需要，另一种方法是创建一个公共方法来创建一个帮助器实例，该方法被标注为<code>#[doc(hidden)]</code>（这样用户就不会看到它）。
然后这个方法可以在rustdoc内部被调用，因为它是crate公共API的一部分。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="临时可变性"><a class="header" href="#临时可变性">临时可变性</a></h1>
<h2 id="描述-14"><a class="header" href="#描述-14">描述</a></h2>
<p>通常在准备和处理一些数据后，数据只是被检查，而不会被修改。
这个意图可以通过重新定义可变变量为不可变的来明确。</p>
<p>这可以通过在嵌套块内处理数据或重新定义变量来实现。</p>
<h2 id="例子-11"><a class="header" href="#例子-11">例子</a></h2>
<p>假定向量在使用前必须进行排序。</p>
<p>使用嵌套块：</p>
<pre><code class="language-rust ignore">let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.
</code></pre>
<p>使用变量重绑定：</p>
<pre><code class="language-rust ignore">let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.
</code></pre>
<h2 id="优势-10"><a class="header" href="#优势-10">优势</a></h2>
<p>由编译器来确保你不会在某个时间点之后意外地改变数据。</p>
<h2 id="劣势-11"><a class="header" href="#劣势-11">劣势</a></h2>
<p>嵌套块需要额外缩进。
多写一行，从块中返回数据或重新定义变量。</p>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Software_design_pattern">设计模式</a> 
是“在软件设计的特定背景下，对一个经常发生的问题的一般可重复使用的解决方案”。
设计模式是描述一种编程语言文化的好方法。
设计模式具有很强的语言特异性——在一种语言中属于模式的东西，在另一种语言中可能由于语言特性而不需要，或者由于缺少特性而无法表达。</p>
<p>如果过度使用，设计模式会给程序增加不必要的复杂性。
然而，它们是分享关于一种编程语言的中高级知识的好方法。</p>
<h2 id="rust中的设计模式-1"><a class="header" href="#rust中的设计模式-1">Rust中的设计模式</a></h2>
<p>Rust有许多特性。这些特性通过消除整类问题给我们带来了巨大的好处。其中有些也是Rust的<strong>独特</strong>模式。</p>
<h2 id="yagni"><a class="header" href="#yagni">YAGNI</a></h2>
<p>如果你不熟悉，YAGNI是一个缩写，代表<code>You Aren't Going to Need It</code>。这是一个重要的软件设计原则，在你写代码时要应用。</p>
<blockquote>
<p>我曾经写过的最好的代码是我从未写过的代码。</p>
</blockquote>
<p>如果我们将YAGNI应用于设计模式，我们会发现Rust的特性允许我们抛开许多模式。
例如，在Rust中没有必要使用<a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a>因为我们有<a href="https://doc.rust-lang.org/book/traits.html">traits</a>。</p>
<p>TODO：加入一些代码来说明这些traits。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="行为型模式"><a class="header" href="#行为型模式">行为型模式</a></h1>
<p>来自<a href="https://en.wikipedia.org/wiki/Behavioral_pattern">Wikipedia</a>：</p>
<blockquote>
<p>识别对象间常见通信模式的设计模式。
这样做增加了进行通信的灵活性。</p>
</blockquote>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令"><a class="header" href="#命令">命令</a></h1>
<h2 id="描述-15"><a class="header" href="#描述-15">描述</a></h2>
<p>命令模式的基本思想是将行动分离成它自己的对象，并将它们作为参数传递。</p>
<h2 id="动机-7"><a class="header" href="#动机-7">动机</a></h2>
<p>假设我们有一连串的行动或事务被封装为对象。
我们希望这些行动或命令之后在不同的时间以某种顺序被执行或调用。
这些命令也可能因某些事件而被触发。
例如，当用户按下一个按钮，或在一个数据包到达时。
此外，这些命令可能是可撤销的。这可能对编辑器的操作很有用。 
我们可能想存储已执行命令的日志，这样，如果系统崩溃，我们可以之后重新应用这些变化。</p>
<h2 id="例子-12"><a class="header" href="#例子-12">例子</a></h2>
<p>定义两个数据库操作<code>create table</code>和<code>add field</code>。每一个操作都是一个可撤销的命令，例如，<code>drop table</code>和<code>remove field</code>。
当用户调用数据库迁移操作时，那么每条命令都按照定义的顺序执行，当用户调用回滚操作时，那么整个命令集将以相反的顺序调用。</p>
<h2 id="方法使用-trait-对象"><a class="header" href="#方法使用-trait-对象">方法：使用 trait 对象</a></h2>
<p>我们定义了一个共同的trait，用两个操作<code>execute</code>和<code>rollback</code>来封装我们的命令。所有的命令<code>structs</code>必须实现这个trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub trait Migration {
    fn execute(&amp;self) -&gt; &amp;str;
    fn rollback(&amp;self) -&gt; &amp;str;
}

pub struct CreateTable;
impl Migration for CreateTable {
    fn execute(&amp;self) -&gt; &amp;str {
        &quot;create table&quot;
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        &quot;drop table&quot;
    }
}

pub struct AddField;
impl Migration for AddField {
    fn execute(&amp;self) -&gt; &amp;str {
        &quot;add field&quot;
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        &quot;remove field&quot;
    }
}

struct Schema {
    commands: Vec&lt;Box&lt;dyn Migration&gt;&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }

    fn add_migration(&amp;mut self, cmd: Box&lt;dyn Migration&gt;) {
        self.commands.push(cmd);
    }

    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands.iter().map(|cmd| cmd.execute()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands
            .iter()
            .rev() // reverse iterator's direction
            .map(|cmd| cmd.rollback())
            .collect()
    }
}

fn main() {
    let mut schema = Schema::new();

    let cmd = Box::new(CreateTable);
    schema.add_migration(cmd);
    let cmd = Box::new(AddField);
    schema.add_migration(cmd);

    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="方法使用函数指针"><a class="header" href="#方法使用函数指针">方法：使用函数指针</a></h2>
<p>我们可以遵循另一种方法，将每个单独的命令创建为不同的函数，并存储函数指针，以便以后在不同的时间调用这些函数。
由于函数指针实现了所有三个trait <code>Fn</code>,<code>FnMut</code>和<code>FnOnce</code>，我们也可以传递和存储闭包而不是函数指针。</p>
<pre><pre class="playground"><code class="language-rust edition2018">type FnPtr = fn() -&gt; String;
struct Command {
    execute: FnPtr,
    rollback: FnPtr,
}

struct Schema {
    commands: Vec&lt;Command&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }
    fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) {
        self.commands.push(Command { execute, rollback });
    }
    fn execute(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands.iter().map(|cmd| (cmd.execute)()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands
            .iter()
            .rev()
            .map(|cmd| (cmd.rollback)())
            .collect()
    }
}

fn add_field() -&gt; String {
    &quot;add field&quot;.to_string()
}

fn remove_field() -&gt; String {
    &quot;remove field&quot;.to_string()
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| &quot;create table&quot;.to_string(), || &quot;drop table&quot;.to_string());
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="方法使用-fn-trait-对象"><a class="header" href="#方法使用-fn-trait-对象">方法：使用 <code>Fn</code> trait 对象</a></h2>
<p>最后，我们可以将实现<code>Fn</code>trait的每个命令分别存储在向量中，而不是定义一个共同的命令trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">type Migration&lt;'a&gt; = Box&lt;dyn Fn() -&gt; &amp;'a str&gt;;

struct Schema&lt;'a&gt; {
    executes: Vec&lt;Migration&lt;'a&gt;&gt;,
    rollbacks: Vec&lt;Migration&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; Schema&lt;'a&gt; {
    fn new() -&gt; Self {
        Self {
            executes: vec![],
            rollbacks: vec![],
        }
    }
    fn add_migration&lt;E, R&gt;(&amp;mut self, execute: E, rollback: R)
    where
        E: Fn() -&gt; &amp;'a str + 'static,
        R: Fn() -&gt; &amp;'a str + 'static,
    {
        self.executes.push(Box::new(execute));
        self.rollbacks.push(Box::new(rollback));
    }
    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.executes.iter().map(|cmd| cmd()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()
    }
}

fn add_field() -&gt; &amp;'static str {
    &quot;add field&quot;
}

fn remove_field() -&gt; &amp;'static str {
    &quot;remove field&quot;
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| &quot;create table&quot;, || &quot;drop table&quot;);
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
    assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h2 id="讨论-6"><a class="header" href="#讨论-6">讨论</a></h2>
<p>如果我们的命令很小，并且可以被定义为函数或者作为一个闭包传递，那么使用函数指针可能是更好的，因为它没有利用动态分发。 
但如果我们的命令是一个完整的结构体，其中有一堆函数和变量被定义为独立的模块，那么使用trait对象会更合适。
应用案例可以在<a href="https://actix.rs/"><code>actix</code></a>中找到，它在为路由注册处理函数时使用trait对象。
在使用<code>Fn</code>trait对象的情况下，我们可以用与函数指针相同的方式创建和使用命令。</p>
<p>关于性能，在性能和代码的简单性和组织性之间总是有一个权衡。
静态分发可以提供更快的性能，而动态分发在我们构造应用程序时提供了灵活性。</p>
<h2 id="参见-9"><a class="header" href="#参见-9">参见</a></h2>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Command_pattern">命令模式</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust">命令模式的另一个例子</a></p>
</li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解释器"><a class="header" href="#解释器">解释器</a></h1>
<h2 id="描述-16"><a class="header" href="#描述-16">描述</a></h2>
<p>如果一个问题经常发生，并且需要长时间重复的步骤来解决，那么问题实例可能用一种简单的语言来表达，一个解释器对象可以通过解释用这种简单语言写的句子来解决这个问题。</p>
<p>基本上，对于我们定义的任何种类的问题：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">领域特定语言</a>，</li>
<li>该语言的语法，</li>
<li>解决问题实例的解释器。</li>
</ul>
<h2 id="动机-8"><a class="header" href="#动机-8">动机</a></h2>
<p>我们的目标是将简单的数学表达式翻译成后缀表达式（或<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">逆波兰表示法</a>）
为了简单起见，我们的表达式由十个数字<code>0</code>，...，<code>9</code>和两个操作符<code>+</code>，<code>-</code>组成。例如，表达式<code>2 + 4</code>被翻译成<code>2 4 +</code>。</p>
<h2 id="有关我们问题的上下文无关文法"><a class="header" href="#有关我们问题的上下文无关文法">有关我们问题的上下文无关文法</a></h2>
<p>我们的任务是把中缀表达式翻译成后缀表达式。 
让我们为<code>0</code>, ..., <code>9</code>, <code>+</code>, 和<code>-</code>上的一组中缀表达式定义一个上下文无关文法，其中：</p>
<ul>
<li>终结符： <code>0</code>, ..., <code>9</code></li>
<li>非终结符： <code>exp</code>, <code>term</code>, <code>+</code>, <code>-</code></li>
<li>起始符是<code>exp</code></li>
<li>接下来是产生规则</li>
</ul>
<pre><code class="language-ignore">exp -&gt; exp + term
exp -&gt; exp - term
exp -&gt; term
term -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p><strong>注意：</strong> 这个文法应该根据我们要做的事情进行进一步的转化。例如，我们可能需要消除左递归。
详情请查阅<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Compilers: Principles,Techniques, and Tools</a>(aka Dragon Book).</p>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>我们简单地实现了一个递归下降分析器。为了简单起见，当一个表达式在语法上出错时（例如，根据语法定义，<code>2-34</code>或<code>2+5-</code>是错误的），代码会panic。</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub struct Interpreter&lt;'a&gt; {
    it: std::str::Chars&lt;'a&gt;,
}

impl&lt;'a&gt; Interpreter&lt;'a&gt; {

    pub fn new(infix: &amp;'a str) -&gt; Self {
        Self { it: infix.chars() }
    }

    fn next_char(&amp;mut self) -&gt; Option&lt;char&gt; {
        self.it.next()
    }

    pub fn interpret(&amp;mut self, out: &amp;mut String) {
        self.term(out);

        while let Some(op) = self.next_char() {
            if op == '+' || op == '-' {
                self.term(out);
                out.push(op);
            } else {
                panic!(&quot;Unexpected symbol '{}'&quot;, op);
            }
        }
    }

    fn term(&amp;mut self, out: &amp;mut String) {
        match self.next_char() {
            Some(ch) if ch.is_digit(10) =&gt; out.push(ch),
            Some(ch) =&gt; panic!(&quot;Unexpected symbol '{}'&quot;, ch),
            None =&gt; panic!(&quot;Unexpected end of string&quot;),
        }
    }
}

pub fn main() {
    let mut intr = Interpreter::new(&quot;2+3&quot;);
    let mut postfix = String::new();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;23+&quot;);

    intr = Interpreter::new(&quot;1-2+3-4&quot;);
    postfix.clear();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, &quot;12-3+4-&quot;);
}
</code></pre></pre>
<h2 id="讨论-7"><a class="header" href="#讨论-7">讨论</a></h2>
<p>可能有一种错误的看法，认为解释器设计模式是关于形式语言的文法设计和这些文法的分析器的实现。
事实上，这种模式是以一种更具体的方式来表达问题实例，并实现解决这些问题实例的函数/类/结构体。
Rust语言有<code>macro_rules!</code>，允许定义特殊的语法和如何将这种语法扩展到源代码的规则。</p>
<p>在下面的例子中，我们创建了一个简单的<code>macro_rules!</code>，计算<code>n</code>维向量的<a href="https://en.wikipedia.org/wiki/Euclidean_distance">欧几里得长度</a>。
写<code>norm!(x,1,2)</code>可能比把<code>x,1,2</code>打包成一个<code>Vec</code>并调用一个计算长度的函数更容易表达和更有效率。</p>
<pre><pre class="playground"><code class="language-rust edition2018">macro_rules! norm {
    ($($element:expr),*) =&gt; {
        {
            let mut n = 0.0;
            $(
                n += ($element as f64)*($element as f64);
            )*
            n.sqrt()
        }
    };
}

fn main() {
    let x = -3f64;
    let y = 4f64;

    assert_eq!(3f64, norm!(x));
    assert_eq!(5f64, norm!(x, y));
    assert_eq!(0f64, norm!(0, 0, 0)); 
    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));
}
</code></pre></pre>
<h2 id="参见-10"><a class="header" href="#参见-10">参见</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a></li>
<li>[上下文无关文法]](https://en.wikipedia.org/wiki/Context-free_grammar)</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro_rules!</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新类型"><a class="header" href="#新类型">新类型</a></h1>
<p>如果在某些情况下，我们希望一个类型的行为类似于另一个类型，或者在编译时强制执行一些行为，而仅仅使用类型别名是不够的，怎么办？</p>
<p>例如，如果我们出于安全考虑（如密码），想为<code>String</code>创建一个自定义的<code>Display</code>实现。</p>
<p>对于这种情况，我们可以使用<code>Newtype</code>模式来提供<strong>类型安全</strong>和<strong>封装</strong>。</p>
<h2 id="描述-17"><a class="header" href="#描述-17">描述</a></h2>
<p>使用单个字段的元组结构体为一个类型做不透明包装。
这将创建一个新的类型，而不是一个类型的别名（<code>type</code>项）。</p>
<h2 id="例子-13"><a class="header" href="#例子-13">例子</a></h2>
<pre><code class="language-rust ignore">// Some type, not necessarily in the same module or even crate.
struct Foo {
    //..
}

impl Foo {
    // These functions are not present on Bar.
    //..
}

// The newtype.
pub struct Bar(Foo);

impl Bar {
    // Constructor.
    pub fn new(
        //..
    ) -&gt; Self {

        //..

    }

    //..
}

fn main() {
    let b = Bar::new(...);

    // Foo and Bar are type incompatible, the following do not type check.
    // let f: Foo = b;
    // let b: Bar = Foo { ... };
}
</code></pre>
<h2 id="动机-9"><a class="header" href="#动机-9">动机</a></h2>
<p>新类型的主要动机是抽象化。它允许你在类型之间共享实现细节，同时精确控制接口。
通过使用新类型而不是将实现类型作为API的一部分公开，它允许你向后兼容地改变实现。</p>
<p>新类型可以用来区分单位，例如，包装<code>f64</code>以获得可区分的<code>Miles</code>和<code>Kms</code>。</p>
<h2 id="优势-11"><a class="header" href="#优势-11">优势</a></h2>
<p>被包装的类型和包装后的类型不是类型兼容的（相对于使用<code>type</code>），所以新类型的用户永远不会“混淆“包装前后的类型。</p>
<p>新类型是一个零成本的抽象——没有运行时的开销。</p>
<p>隐私系统确保用户无法访问被包装的类型（如果字段是私有的，默认情况下是私有的）。</p>
<h2 id="劣势-12"><a class="header" href="#劣势-12">劣势</a></h2>
<p>新类型的缺点（尤其是与类型别名相比）是没有特殊的语言支持。这意味着可能会有<em>许多</em>模板代码。
你需要为你想在包装类型上公开的每个方法提供一个”通过“方法，并为你想在包装类型上实现的每个trait提供一个实现。</p>
<h2 id="讨论-8"><a class="header" href="#讨论-8">讨论</a></h2>
<p>新类型在Rust代码中非常常见。抽象或代表单位是最常见的用途，但它们也可以用于其他原因：</p>
<ul>
<li>限制功能（减少暴露的函数或实现的trait），</li>
<li>使一个具有复制语义的类型具有移动语义，</li>
<li>通过提供一个更具体的类型，从而隐藏内部类型来实现抽象，
例如，</li>
</ul>
<pre><code class="language-rust ignore">pub struct Foo(Bar&lt;T1, T2&gt;);
</code></pre>
<p>这里，<code>Bar</code>可能是一些公共的、通用的类型，<code>T1</code>和<code>T2</code>是一些内部类型。
我们模块的用户不应该知道我们通过使用<code>Bar</code>来实现<code>Foo</code>，但我们在这里真正隐藏的是<code>T1</code>和<code>T2</code>类型，以及它们如何与<code>Bar</code>一起使用。</p>
<h2 id="参见-11"><a class="header" href="#参见-11">参见</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-abstraction">“圣经“中的高级类型</a></li>
<li><a href="https://wiki.haskell.org/Newtype">Haskell中的新类型</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">类型别名</a></li>
<li><a href="https://crates.io/crates/derive_more">derive_more</a>是一个用于在新类型上派生许多内置trait的crate。</li>
<li><a href="https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html">Rust中的新类型模式</a></li>
</ul>
<blockquote>
<p>Latest commit 11a0a13 Dec 14 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="有守护的raii"><a class="header" href="#有守护的raii">有守护的RAII</a></h1>
<h2 id="描述-18"><a class="header" href="#描述-18">描述</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>代表&quot;Resource Acquisition is Initialisation&quot;，”资源获取即初始化“。
该模式的本质是，资源初始化在对象的构造器中完成，最终化（资源释放）在析构器中完成。
这种模式在Rust中得到了扩展，即使用RAII对象作为某些资源的守护对象，并依靠类型系统来确保访问总是由守护对象来调解。</p>
<h2 id="例子-14"><a class="header" href="#例子-14">例子</a></h2>
<p>互斥守护是std库中这种模式的典型例子（这是真正实现的简化版本）：</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Foo {}

struct Mutex&lt;T&gt; {
    // We keep a reference to our data: T here.
    //..
}

struct MutexGuard&lt;'a, T: 'a&gt; {
    data: &amp;'a T,
    //..
}

// Locking the mutex is explicit.
impl&lt;T&gt; Mutex&lt;T&gt; {
    fn lock(&amp;self) -&gt; MutexGuard&lt;T&gt; {
        // Lock the underlying OS mutex.
        //..

        // MutexGuard keeps a reference to self
        MutexGuard {
            data: self,
            //..
        }
    }
}

// Destructor for unlocking the mutex.
impl&lt;'a, T&gt; Drop for MutexGuard&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Unlock the underlying OS mutex.
        //..
    }
}

// Implementing Deref means we can treat MutexGuard like a pointer to T.
impl&lt;'a, T&gt; Deref for MutexGuard&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.data
    }
}

fn baz(x: Mutex&lt;Foo&gt;) {
    let xx = x.lock();
    xx.foo(); // foo is a method on Foo.
    // The borrow checker ensures we can't store a reference to the underlying
    // Foo which will outlive the guard xx.

    // x is unlocked when we exit this function and xx's destructor is executed.
}
</code></pre>
<h2 id="动机-10"><a class="header" href="#动机-10">动机</a></h2>
<p>如果一个资源在使用后必须进行最终处理，RAII可以用来进行最终处理。
如果在最终处理后访问该资源是一个错误，那么这个模式可以用来防止这种错误。</p>
<h2 id="优势-12"><a class="header" href="#优势-12">优势</a></h2>
<p>防止在资源没有最终处理和在最终处理后使用资源时出现错误。</p>
<h2 id="讨论-9"><a class="header" href="#讨论-9">讨论</a></h2>
<p>RAII是一种有用的模式，可以确保资源被适当地取消分配或被最终处理。
我们可以利用Rust中的借用检查器来静态地防止在最终处理完成后使用资源所产生的错误。</p>
<p>借用检查器的核心目的是确保对数据的引用不会超过该数据的生命周期。
RAII守护模式之所以有效，是因为守护对象包含了对底层资源的引用，并且只暴露了这种引用。
Rust确保守护对象不能超过底层资源的生命周期，并且守护对象所调解资源的引用不能超过守护对象的生命周期。
为了解这一点，检查一下没有生命周期标注的<code>deref</code>的签名是有帮助的。</p>
<pre><code class="language-rust ignore">fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {
    //..
}
</code></pre>
<p>返回的资源引用与<code>self</code>具有相同的生命周期(<code>'a</code>)。
因此，借用检查器确保对<code>T</code>的引用的生命周期短于（不超过）<code>self</code>的生命周期。</p>
<p>请注意，实现<code>Deref</code>并不是这个模式的核心部分，它只是让使用守护对象更符合人体工程学。
在守护对象上实现一个<code>get</code>方法也同样有效。</p>
<h2 id="参见-12"><a class="header" href="#参见-12">参见</a></h2>
<p><a href="patterns/behavioural/../../idioms/dtor-finally.html">惯常做法：析构器中的最终处理</a></p>
<p>RAII是C++中的一种常见模式：<a href="http://en.cppreference.com/w/cpp/language/raii">cppreference.com</a>,
<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">wikipedia</a>.</p>
<p><a href="https://doc.rust-lang.org/1.0.0/style/ownership/raii.html">风格指南条目</a>
（目前仅是占位符）。</p>
<blockquote>
<p>Latest commit b809265 on 22 Apr 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="策略也称-政策"><a class="header" href="#策略也称-政策">策略（也称 政策）</a></h1>
<h2 id="描述-19"><a class="header" href="#描述-19">描述</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略设计模式</a>是一种实现关注点分离的技术。它还允许通过<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖反转</a>来解耦软件模块。</p>
<p>策略模式的基本思想是，给定一个解决特定问题的算法，我们只在抽象层面上定义算法的骨架，并将具体的算法实现分成不同的部分。</p>
<p>这样，使用该算法的客户可以选择一个具体的实现，而一般的算法工作流程保持不变。
换句话说，类的抽象规范并不取决于派生类的具体实现，但具体实现必须遵守抽象规范。
这就是为什么我们称之为“依赖反转”。</p>
<h2 id="动机-11"><a class="header" href="#动机-11">动机</a></h2>
<p>想象一下，我们正在做一个每月都会生成报告的项目。
我们需要以不同的格式（策略）生成报告，例如，以<code>JSON</code>或<code>Plain Text</code>格式。
但事情随着时间的推移而变化，我们不知道未来可能得到什么样的要求。
例如，我们可能需要以一种全新的格式生成我们的报告，或者只是修改现有的一种格式。</p>
<h2 id="例子-15"><a class="header" href="#例子-15">例子</a></h2>
<p>在这个例子中，我们的不变量（或抽象）是<code>Context</code>、<code>Formatter</code>和<code>Report</code>，而<code>Text</code>和<code>Json</code>是我们的策略结构体。
这些策略必须实现<code>Formatter</code>的trait。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::collections::HashMap;

type Data = HashMap&lt;String, u32&gt;;

trait Formatter {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String);
}

struct Report;

impl Report {
    // Write should be used but we kept it as String to ignore error handling
    fn generate&lt;T: Formatter&gt;(g: T, s: &amp;mut String) {
        // backend operations...
        let mut data = HashMap::new();
        data.insert(&quot;one&quot;.to_string(), 1);
        data.insert(&quot;two&quot;.to_string(), 2);
        // generate report
        g.format(&amp;data, s);
    }
}

struct Text;
impl Formatter for Text {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        for (k, v) in data {
            let entry = format!(&quot;{} {}\n&quot;, k, v);
            buf.push_str(&amp;entry);
        }
    }
}

struct Json;
impl Formatter for Json {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        buf.push('[');
        for (k, v) in data.into_iter() {
            let entry = format!(r#&quot;{{&quot;{}&quot;:&quot;{}&quot;}}&quot;#, k, v);
            buf.push_str(&amp;entry);
            buf.push(',');
        }
        buf.pop(); // remove extra , at the end
        buf.push(']');
    }
}

fn main() {
    let mut s = String::from(&quot;&quot;);
    Report::generate(Text, &amp;mut s);
    assert!(s.contains(&quot;one 1&quot;));
    assert!(s.contains(&quot;two 2&quot;));

    s.clear(); // reuse the same buffer
    Report::generate(Json, &amp;mut s);
    assert!(s.contains(r#&quot;{&quot;one&quot;:&quot;1&quot;}&quot;#));
    assert!(s.contains(r#&quot;{&quot;two&quot;:&quot;2&quot;}&quot;#));
}
</code></pre></pre>
<h2 id="优势-13"><a class="header" href="#优势-13">优势</a></h2>
<p>主要优势是关注点分离。
例如，在这种情况下，<code>Report</code>对<code>Json</code>和<code>Text</code>的具体实现一无所知，而输出实现则不关心数据如何被预处理、存储和获取。
他们唯一需要知道的是上下文和要实现的特定trait和方法，即<code>Formatter</code>和<code>format</code>。</p>
<h2 id="劣势-13"><a class="header" href="#劣势-13">劣势</a></h2>
<p>每个策略必须至少有一个模块，所以模块的数量随着策略的数量而增加。
如果有许多策略可供选择，那么用户就必须知道策略之间有什么不同。</p>
<h2 id="讨论-10"><a class="header" href="#讨论-10">讨论</a></h2>
<p>在前面的例子中，所有策略都在一个文件中实现。
提供不同策略的方法包括：</p>
<ul>
<li>都在一个文件中（如本例所示，类似于作为模块分离的情况）</li>
<li>作为模块分开，例如，<code>formatter::json</code>模块，<code>formatter::text</code>模块</li>
<li>使用编译器特性标记，例如<code>json</code>特征，<code>text</code>特征</li>
<li>作为crate分开，例如：<code>json</code>crate，<code>text</code>crate</li>
</ul>
<p>Serde crate是<code>策略</code>模式在实践中的一个好例子。
Serde允许通过为我们的类型手动实现<code>Serialize</code>和<code>Deserialize</code>trait来对序列化行为进行<a href="https://serde.rs/custom-serialization.html">完全定制</a>。
例如，我们可以很容易地将<code>serde_json</code>与<code>serde_cbor</code>交换，因为它们暴露了类似的方法。
有了这一点，使得助手crate<code>serde_transcode</code>更加有用和符合人体工程学。</p>
<p>然而，我们不需要使用traits就可以在Rust中设计这种模式。</p>
<p>下面的玩具例子演示了使用Rust<code>closures</code>策略模式的想法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Adder;
impl Adder {
    pub fn add&lt;F&gt;(x: u8, y: u8, f: F) -&gt; u8
    where
        F: Fn(u8, u8) -&gt; u8,
    {
        f(x, y)
    }
}

fn main() {
    let arith_adder = |x, y| x + y;
    let bool_adder = |x, y| {
        if x == 1 || y == 1 {
            1
        } else {
            0
        }
    };
    let custom_adder = |x, y| 2 * x + y;

    assert_eq!(9, Adder::add(4, 5, arith_adder));
    assert_eq!(0, Adder::add(0, 0, bool_adder));
    assert_eq!(5, Adder::add(1, 3, custom_adder));
}

</code></pre></pre>
<p>事实上，Rust已经在<code>Options</code>的<code>map</code>方法中使用了这个想法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let val = Some(&quot;Rust&quot;);

    let len_strategy = |s: &amp;str| s.len();
    assert_eq!(4, val.map(len_strategy).unwrap());

    let first_byte_strategy = |s: &amp;str| s.bytes().next().unwrap();
    assert_eq!(82, val.map(first_byte_strategy).unwrap());
}
</code></pre></pre>
<h2 id="参见-13"><a class="header" href="#参见-13">参见</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Strategy_pattern">策略模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">依赖注入</a></li>
<li><a href="https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design">基于政策的设计</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问器"><a class="header" href="#访问器">访问器</a></h1>
<h2 id="描述-20"><a class="header" href="#描述-20">描述</a></h2>
<p>访问器封装了一种在对象的异质集合上操作的算法。
它允许在同一数据上写入多种不同的算法，而不必修改数据（或其主要行为）。</p>
<p>此外，访问器模式允许将对象集合的遍历与对每个对象进行的操作分开。</p>
<h2 id="例子-16"><a class="header" href="#例子-16">例子</a></h2>
<pre><code class="language-rust ignore">// The data we will visit
mod ast {
    pub enum Stmt {
        Expr(Expr),
        Let(Name, Expr),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract visitor
mod visit {
    use ast::*;

    pub trait Visitor&lt;T&gt; {
        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T;
        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T;
        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T;
    }
}

use visit::*;
use ast::*;

// An example concrete implementation - walks the AST interpreting it as code.
struct Interpreter;
impl Visitor&lt;i64&gt; for Interpreter {
    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 { panic!() }
    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {
        match *s {
            Stmt::Expr(ref e) =&gt; self.visit_expr(e),
            Stmt::Let(..) =&gt; unimplemented!(),
        }
    }

    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {
        match *e {
            Expr::IntLit(n) =&gt; n,
            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self.visit_expr(rhs),
            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self.visit_expr(rhs),
        }
    }
}
</code></pre>
<p>人们可以实现更多的访问器，例如类型检查器，而不需要修改AST数据。</p>
<h2 id="动机-12"><a class="header" href="#动机-12">动机</a></h2>
<p>访问器模式在任何你想将算法应用于异质数据的地方都很有用。
如果数据是同质的，你可以使用一个类似迭代器的模式。
使用访问器对象（而不是功能化的方法）允许访问器是有状态的，从而在节点之间交流信息。</p>
<h2 id="讨论-11"><a class="header" href="#讨论-11">讨论</a></h2>
<p><code>visit_*</code>方法通常会返回void（与例子中不同）。
在这种情况下，有可能将遍历代码抽取出来，并在算法之间共享（也可以提供noop默认方法）。 
在Rust中，常见的方法是为每个数据点提供<code>walk_*</code>函数。
例如，</p>
<pre><code class="language-rust ignore">pub fn walk_expr(visitor: &amp;mut Visitor, e: &amp;Expr) {
    match *e {
        Expr::IntLit(_) =&gt; {},
        Expr::Add(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
        Expr::Sub(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
    }
}
</code></pre>
<p>在其他语言中（例如Java），数据通常有一个<code>accept</code>方法，担任同样的职责。</p>
<h2 id="参见-14"><a class="header" href="#参见-14">参见</a></h2>
<p>访问器模式是大多数OO语言中的一种常见模式。</p>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">访问器模式</a></p>
<p><a href="patterns/behavioural/../creational/fold.html">fold</a>模式与visitor类似，但产生一个新版本的被访数据结构。</p>
<blockquote>
<p>Latest commit b809265 on 22 Apr 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建型模式"><a class="header" href="#创建型模式">创建型模式</a></h1>
<p>来自<a href="https://en.wikipedia.org/wiki/Creational_pattern">Wikipedia</a>：</p>
<blockquote>
<p>处理对象创建机制的设计模式，试图以适合情况的方式创建对象。
对象创建的基本形式可能导致设计问题或增加设计的复杂性。
创建型设计模式通过某种方式控制这种对象的创建来解决这个问题。</p>
</blockquote>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成器"><a class="header" href="#生成器">生成器</a></h1>
<h2 id="描述-21"><a class="header" href="#描述-21">描述</a></h2>
<p>通过对生成器助手的调用构造一个对象。</p>
<h2 id="例子-17"><a class="header" href="#例子-17">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机-13"><a class="header" href="#动机-13">动机</a></h2>
<p>当你需要许多构造器或构造有副作用时，这很有用。</p>
<h2 id="优势-14"><a class="header" href="#优势-14">优势</a></h2>
<p>将构建的方法与其他方法分开。</p>
<p>防止构造器的泛滥。</p>
<p>可用于单行的初始化，也可用于更复杂的构造。</p>
<h2 id="劣势-14"><a class="header" href="#劣势-14">劣势</a></h2>
<p>比直接创建一个结构体对象，或一个简单的构造器更复杂。</p>
<h2 id="讨论-12"><a class="header" href="#讨论-12">讨论</a></h2>
<p>这种模式在Rust中比其他许多语言更频繁地出现（对于更简单的对象），因为Rust缺乏重载。
因为你只能有一个给定名称的单一方法，所以在Rust中拥有多个构造器就不如在C++、Java或其他语言中那么好。</p>
<p>这种模式通常用于生成器对象本身就很有用，而不仅仅是一个生成器。
例如，<a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a>是<a href="https://doc.rust-lang.org/std/process/struct.Child.html"><code>Child</code></a>（一个进程）的生成器。
在这些情况下，不使用<code>T'和</code>TBuilder'的命名模式。</p>
<p>这个例子通过值传递的方式获取并返回生成器。
通常情况下，将生成器作为一个可变引用来获取和返回，更符合人体工程学（也更高效）。
借用检查器使这一工作自然进行。 
这种方法的好处是，人们可以写出像这样的代码：</p>
<pre><code class="language-rust ignore">let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.build();
</code></pre>
<p>以及<code>FooBuilder::new().a().b().build()</code>风格。</p>
<h2 id="参见-15"><a class="header" href="#参见-15">参见</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">风格指南中的描述</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>，这是个自动实现这种模式的crate，同时避免了模板代码。</li>
<li><a href="patterns/creational/../../idioms/ctor.html">Constructor pattern</a>用于构造比较简单的时候。</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">生成器模式(wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">复杂值的构造</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fold"><a class="header" href="#fold">Fold</a></h1>
<h2 id="描述-22"><a class="header" href="#描述-22">描述</a></h2>
<p>在数据集的每一项上运行一个算法，以创建一个新的项，从而创建一个全新的集合。</p>
<p>我不清楚这里的词源。
Rust编译器中使用了<code>fold</code>和<code>folder</code>这两个术语，尽管在我看来，它更像<code>map</code>，而不是通常意义上的<code>fold</code>。 
更多细节见下面的讨论。</p>
<h2 id="例子-18"><a class="header" href="#例子-18">例子</a></h2>
<pre><code class="language-rust ignore">// The data we will fold, a simple AST.
mod ast {
    pub enum Stmt {
        Expr(Box&lt;Expr&gt;),
        Let(Box&lt;Name&gt;, Box&lt;Expr&gt;),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract folder
mod fold {
    use ast::*;

    pub trait Folder {
        // A leaf node just returns the node itself. In some cases, we can do this
        // to inner nodes too.
        fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; { n }
        // Create a new inner node by folding its children.
        fn fold_stmt(&amp;mut self, s: Box&lt;Stmt&gt;) -&gt; Box&lt;Stmt&gt; {
            match *s {
                Stmt::Expr(e) =&gt; Box::new(Stmt::Expr(self.fold_expr(e))),
                Stmt::Let(n, e) =&gt; Box::new(Stmt::Let(self.fold_name(n), self.fold_expr(e))),
            }
        }
        fn fold_expr(&amp;mut self, e: Box&lt;Expr&gt;) -&gt; Box&lt;Expr&gt; { ... }
    }
}

use fold::*;
use ast::*;

// An example concrete implementation - renames every name to 'foo'.
struct Renamer;
impl Folder for Renamer {
    fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; {
        Box::new(Name { value: &quot;foo&quot;.to_owned() })
    }
    // Use the default methods for the other nodes.
}
</code></pre>
<p>在AST上运行<code>Renamer</code>的结果是一个与旧AST相同的新AST，但每个名字都改为<code>foo</code>。
现实生活中的<code>folder</code>可能会在结构本身的节点之间保留一些状态。</p>
<p>也可以定义一个<code>folder</code>，将一个数据结构映射到一个不同的（但通常是类似的）数据结构。
例如，我们可以将AST<code>fold</code>成HIR树（HIR代表high-level intermediate representation，高级中间表示法）。</p>
<h2 id="动机-14"><a class="header" href="#动机-14">动机</a></h2>
<p>通过对结构中的每个节点进行一些操作来映射一个数据结构是很常见的。 
对于简单数据结构的简单操作，可以使用<code>Iterator::map</code>来完成。
对于更复杂的操作，也许前面的节点会影响后面节点的操作，或者在数据结构上的迭代不是简单的，使用<code>fold</code>模式更合适。</p>
<p>与访问器模式一样，<code>fold</code>模式允许我们将数据结构的遍历与对每个节点进行的操作分开。</p>
<h2 id="讨论-13"><a class="header" href="#讨论-13">讨论</a></h2>
<p>以这种方式映射数据结构在函数式语言中是很常见的。
在OO语言中，更常见的是在原地改变数据结构。
“函数式”方法在Rust中很常见，主要是由于对不可变性的偏好。
使用新的数据结构，而不是改变旧的数据结构，在大多数情况下使代码推理更容易。</p>
<p>通过改变<code>fold_*</code>方法接受节点的方式，可以对效率和可重用性之间的权衡进行调整。</p>
<p>在上面的例子中，我们对<code>Box</code>指针进行操作。由于这些指针排他地拥有其数据，数据结构的原始副本不能被重新使用。
另一方面，如果一个节点没有改变，重新使用它是非常有效的。</p>
<p>如果我们对借来的引用进行操作，原来的数据结构可以被重用；但是，一个节点即使没有变化，也必须被克隆，这可能很昂贵。</p>
<p>使用引用计数指针可以获得两全其美的效果——我们可以重用原来的数据结构，而且我们不需要克隆未改变的节点。
然而，它们在使用上不太符合人体工程学，而且意味着数据结构不能被改变。</p>
<h2 id="参见-16"><a class="header" href="#参见-16">参见</a></h2>
<p>迭代器有一个<code>fold</code>方法，但是这个方法将一个数据结构<code>fold</code>成一个值，而不是<code>fold</code>成一个新的数据结构。迭代器的<code>map</code>更像是这种<code>fold</code>模式。</p>
<p>在其他语言中，<code>fold</code>通常是在Rust迭代器的意义上使用，而不是这种模式。
一些函数式语言拥有强大的结构，可以对数据结构进行灵活的映射。</p>
<p><a href="patterns/creational/../behavioural/visitor.html">访问器</a>模式与<code>fold</code>密切相关。
它们的共同概念是在一个数据结构上遍历，对每个节点进行操作。
然而，访问器模式并不创建一个新的数据结构，也不消耗旧的数据结构。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构型模式"><a class="header" href="#结构型模式">结构型模式</a></h1>
<p>来自<a href="https://en.wikipedia.org/wiki/Structural_pattern">Wikipedia</a>：</p>
<blockquote>
<p>通过确定一种实现实体间关系的简单方法来简化设计的设计模式</p>
</blockquote>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="将结构体组合在一起以获得更好的借用"><a class="header" href="#将结构体组合在一起以获得更好的借用">将结构体组合在一起以获得更好的借用</a></h1>
<p>TODO - 这不是一个简洁的名字</p>
<h2 id="描述-23"><a class="header" href="#描述-23">描述</a></h2>
<p>有时一个大的结构体会给借用检查器带来问题——虽然字段可以被独立借用，但有时整个结构体最终会被一次性使用，从而妨碍其他用途。
一个解决方案可能是将该结构体分解为几个较小的结构体。
然后将这些结构体组合为原始结构体。
然后每个结构体都可以被单独借用，并具有更灵活的行为。</p>
<p>这往往会在其他方面带来更好的设计：应用这种设计模式往往能发现更小的功能单元。</p>
<h2 id="例子-19"><a class="header" href="#例子-19">例子</a></h2>
<p>下面是一个精心设计的例子，说明借用检查器挫败了我们使用结构体的计划：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    f1: u32,
    f2: u32,
    f3: u32,
}

fn foo(a: &amp;mut A) -&gt; &amp;u32 { &amp;a.f2 }
fn bar(a: &amp;mut A) -&gt; u32 { a.f1 + a.f3 }

fn baz(a: &amp;mut A) {
    // The later usage of x causes a to be borrowed for the rest of the function.
    let x = foo(a);
    // Borrow checker error:
    // let y = bar(a); // ~ ERROR: cannot borrow `*a` as mutable more than once
                       //          at a time
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以应用这种设计模式，将<code>A</code>重构为两个较小的结构体，从而解决借用检查问题：</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A is now composed of two structs - B and C.
struct A {
    b: B,
    c: C,
}
struct B {
    f2: u32,
}
struct C {
    f1: u32,
    f3: u32,
}

// These functions take a B or C, rather than A.
fn foo(b: &amp;mut B) -&gt; &amp;u32 { &amp;b.f2 }
fn bar(c: &amp;mut C) -&gt; u32 { c.f1 + c.f3 }

fn baz(a: &amp;mut A) {
    let x = foo(&amp;mut a.b);
    // Now it's OK!
    let y = bar(&amp;mut a.c);
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机-15"><a class="header" href="#动机-15">动机</a></h2>
<p>TODO 为什么以及在哪里应该使用该模式。</p>
<h2 id="优势-15"><a class="header" href="#优势-15">优势</a></h2>
<p>让你可以绕过借用检查器的限制。</p>
<p>通常会产生一个更好的设计。</p>
<h2 id="劣势-15"><a class="header" href="#劣势-15">劣势</a></h2>
<p>导致更多冗长的代码。</p>
<p>有时，较小的结构体并不是很好的抽象，所以我们最终得到了一个更糟糕的设计。
这可能是一种“代码气味”，表明该程序应该以某种方式进行重构。</p>
<h2 id="讨论-14"><a class="header" href="#讨论-14">讨论</a></h2>
<p>这种模式在没有借用检查器的语言中是不需要的，所以从这个意义上说是Rust独有的。
然而，将功能单元做得更小，往往能使代码更简洁：这是软件工程中公认的原则，与语言无关。</p>
<p>这个模式依赖于Rust的借用检查器能够独立借用字段。
在这个例子中，借用检查器知道<code>a.b</code>和<code>a.c</code>是不同的，可以独立借用，它不会试图借用<code>a</code>的全部，这将使这个模式毫无用处。</p>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="倾向于较小的crates"><a class="header" href="#倾向于较小的crates">倾向于较小的crates</a></h1>
<h2 id="描述-24"><a class="header" href="#描述-24">描述</a></h2>
<p>倾向于选择能做好一件事的较小的crates。</p>
<p>Cargo和crates.io使得添加第三方库变得很容易，比C或C++等语言要容易得多。
此外，由于crates.io上的包在发布后不能被编辑或删除，任何现在能工作的构建在未来也应该继续工作。
我们应该利用这种工具的优势，使用更小、更细的依赖关系。</p>
<h2 id="优势-16"><a class="header" href="#优势-16">优势</a></h2>
<ul>
<li>小的crates更容易理解，并鼓励更多的模块化代码。</li>
<li>Crates允许在项目之间重用代码。
例如，<code>url</code>crate是作为Servo浏览器引擎的一部分而开发的，但后来在该项目之外被广泛使用。</li>
<li>由于Rust的编译单元是crate，将一个项目分割成多个crate可以使更多的代码被并行构建。</li>
</ul>
<h2 id="劣势-16"><a class="header" href="#劣势-16">劣势</a></h2>
<ul>
<li>当一个项目同时依赖一个crate的多个冲突版本时，这可能导致“依赖地狱”。例如，<code>url</code>crate有1.0和0.5两个版本。由于<code>url:1.0</code>的<code>Url</code>和<code>url:0.5</code>的<code>Url</code>是不同的类型，使用<code>url:0.5</code>的HTTP客户端将不接受来自使用<code>url:1.0</code>的Web爬虫的<code>Url</code>值。</li>
<li>crates.io上的软件包没有经过组织。一个crate可能写得很差，有无用的文档，或直接是恶意的。</li>
<li>两个小crate的优化程度可能低于一个大crate，因为编译器默认不执行链接时优化（link-time optimization,LTO）。</li>
</ul>
<h2 id="例子-20"><a class="header" href="#例子-20">例子</a></h2>
<p><a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> 提供将<code>&amp;T</code>转换为<code>&amp;[T]</code>函数的crate。</p>
<p><a href="https://crates.io/crates/url"><code>url</code></a>提供处理URLs工具的crate。</p>
<p><a href="https://crates.io/crates/num_cpus"><code>num_cpus</code></a>提供一个函数来查询机器上的CPU数量的crate。</p>
<h2 id="参见-17"><a class="header" href="#参见-17">参见</a></h2>
<ul>
<li><a href="https://crates.io/">crates.io: The Rust community crate host</a></li>
</ul>
<blockquote>
<p>Latest commit 881f51f on 8 Mar 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="把不安全因素放在小模块中"><a class="header" href="#把不安全因素放在小模块中">把不安全因素放在小模块中</a></h1>
<h2 id="描述-25"><a class="header" href="#描述-25">描述</a></h2>
<p>如果你有<code>unsafe</code>的代码，创建一个尽可能小的模块，它可以坚持在不安全的基础上建立一个最小的安全接口所需的不变量。
将其嵌入到一个更大的模块中，该模块只包含安全代码，并提供一个符合人体工程学的接口。
注意，外部模块可以包含直接调用不安全代码的不安全函数和方法。用户可以用它来获得速度上的好处。</p>
<h2 id="优势-17"><a class="header" href="#优势-17">优势</a></h2>
<ul>
<li>限制必须被审计的不安全代码。</li>
<li>编写外部模块要容易得多，因为你可以依靠内部模块的保证。</li>
</ul>
<h2 id="劣势-17"><a class="header" href="#劣势-17">劣势</a></h2>
<ul>
<li>有时，可能很难找到一个合适的接口。</li>
<li>抽象可能会带来效率低下的问题。</li>
</ul>
<h2 id="例子-21"><a class="header" href="#例子-21">例子</a></h2>
<ul>
<li><a href="https://docs.rs/toolshed"><code>toolshed</code></a>crate在子模块中包含其不安全的操作，为用户提供了一个安全的接口。</li>
<li><code>std</code>的<code>String</code>类是对<code>Vec&lt;u8&gt;</code>的封装，增加了内容必须是有效UTF-8的不变量。对<code>String</code>的操作确保了这种行为。
然而，用户可以选择使用一个<code>unsafe</code>的方法来创建一个<code>String</code>，在这种情况下，他们有责任保证内容的有效性。</li>
</ul>
<h2 id="参见-18"><a class="header" href="#参见-18">参见</a></h2>
<ul>
<li><a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">Ralf Jung的博客，关于不安全代码中的不变量</a></li>
</ul>
<blockquote>
<p>Latest commit 044d365 on 25 Nov 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-模式"><a class="header" href="#ffi-模式">FFI 模式</a></h1>
<p>编写FFI代码本身就是一个完整的课程。
尽管如此，这还是有几个惯常做法可以作为指导，避免对unsafe Rust缺乏经验的用户踩坑。</p>
<p>本节包含在开发FFI时可能有用的设计模式。</p>
<ol>
<li>
<p><a href="patterns/ffi/./export.html">基于对象的API</a>是具有良好内存安全特性的设计，对代码安全与否有明确界限。</p>
</li>
<li>
<p><a href="patterns/ffi/./wrappers.html">类型合并</a>——将多个Rust类型组合成一个不透明的“对象”。</p>
</li>
</ol>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于对象的api"><a class="header" href="#基于对象的api">基于对象的API</a></h1>
<h2 id="描述-26"><a class="header" href="#描述-26">描述</a></h2>
<p>当在Rust中设计暴露于其他语言的API时，有一些重要的设计原则与正常的Rust API设计相反：</p>
<ol>
<li>所有的封装类型都应该被Rust<em>拥有</em>，由用户<em>管理</em>，并且<em>不透明</em>。</li>
<li>所有的事务性数据类型都应该由用户<em>拥有</em>，并且是<em>透明</em>的。</li>
<li>所有的库行为应该是作用于封装类型的函数。</li>
<li>所有的库行为都应该被封装成类型，且不是基于结构，而是基于<em>出处/生命周期</em>。</li>
</ol>
<h2 id="动机-16"><a class="header" href="#动机-16">动机</a></h2>
<p>Rust有对其他语言的内置FFI支持。
它为crate作者提供一种方法，通过不同的ABI（尽管这对这种做法并不重要）提供与C兼容的API。</p>
<p>设计良好的Rust FFI遵循了C语言API的设计原则，同时在Rust中尽可能地减少设计的妥协。任何外部API都有三个目标：</p>
<ol>
<li>使其易于在目标语言中使用。</li>
<li>尽可能避免API在Rust侧控制内部不安全性。</li>
<li>尽可能地减少内存不安全性和Rust<code>undefined behaviour</code>的可能性。</li>
</ol>
<p>Rust代码必须在一定程度上相信外部语言的内存安全性。
然而，Rust侧每一点<code>unsafe</code>的代码都是产生错误的机会，或者加剧了<code>undefined behaviour</code>。</p>
<p>例如，如果一个指针的出处是错误的，这可能是由于无效的内存访问造成的段错误。
同时，如果它被不安全的代码所操纵，它就可能成为全面的堆损坏。</p>
<p>基于对象的API设计允许编写具有良好内存安全特性的垫片代码，拥有明确的安全界限。</p>
<h2 id="代码示例-3"><a class="header" href="#代码示例-3">代码示例</a></h2>
<p>POSIX标准定义了访问文件式数据库的API，被称为<a href="https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h">DBM</a>。
它是一个“基于对象”的API的优秀例子。</p>
<p>下面是C语言的定义，对参与FFI的人来说应该很容易读懂。
下面的评论应该有助于解释细微差别。</p>
<pre><code class="language-C">struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
</code></pre>
<p>这个API定义了两种类型：<code>DBM</code>和<code>datum</code>。</p>
<p><code>DBM</code>类型即上文所称的“封装类型”。
它被设计为包含内部状态，并作为库行为的入口。</p>
<p>它对用户是完全不透明的，用户不能自己创建一个<code>DBM</code>，因为他们不知道它的大小和布局。
相反，他们必须调用<code>dbm_open</code>，而这只能给他们一个<em>指向<code>DBM</code>的指针</em>。</p>
<p>这意味着所有的<code>DBM</code>在Rust意义上是由库“拥有”的。
未知大小的内部状态被保存在由库控制的内存中，而不是用户。
用户只能通过<code>open</code>和<code>close</code>来管理它的生命周期，并通过其他函数对它进行操作。</p>
<p><code>datum</code>类型即上文所称的“事务性数据类型”。
它被设计用来促进库和用户之间的信息交流。</p>
<p>该数据库被设计用来存储“非结构化数据”，没有预先定义的长度或意义。
因此，<code>datum</code>相当于C语言中的Rust slice：一串字节，以及有多少个字节的计数。主要的区别是没有类型信息，也就是<code>void</code>所表示的。</p>
<p>请记住，这个头文件是从库的角度来写的。
用户可能有一些他们正在使用的类型，这些类型有已知的大小。
但是库并不关心，根据C语言的转换规则，指针后面的任何类型都可以被转换为<code>void</code>。</p>
<p>如前所述，这种类型对用户来说是<em>透明</em>的，同时这个类型也是由用户<em>拥有</em>的。
由于其内部指针，这有微妙的影响。
问题是，谁拥有这个指针所指向的内存？</p>
<p>对于最佳的内存安全性来说，答案是“用户”。
但是在诸如检索一个值的情况下，用户不知道如何正确地分配它（因为他们不知道这个值有多长）。
在这种情况下，库的代码应该使用用户可以访问的堆——比如C库的<code>malloc</code>和<code>free</code>——然后在Rust意义上<em>转移所有权</em>。</p>
<p>这似乎都是猜测，但这就是C语言中指针的含义。
它和Rust的意思是一样的：“用户定义的生命周期”。
库的用户需要阅读文档，以便正确使用它。
也就是说，有一些决定，如果用户做错了，会产生或大或小的后果。
尽量减少这些是这个最佳实践的目的，关键是要<em>转移一切透明事务的所有权</em>。</p>
<h2 id="优势-18"><a class="header" href="#优势-18">优势</a></h2>
<p>这使用户必须坚持的内存安全保证的数量降到相对较少：</p>
<ol>
<li>不要用不是由<code>dbm_open</code>返回的指针调用任何函数（无效访问或损坏）。</li>
<li>关闭之后，不要在指针上调用任何函数（在free后使用）。</li>
<li>任何<code>datum</code>上的<code>dptr</code>必须是<code>NULL</code>，或者指向一个有效的内存片，其长度为所声明的长度。</li>
</ol>
<p>此外，它还避免了很多指针出处的问题。
为了理解原因，让我们深入考虑一个替代方案：键的迭代。</p>
<p>Rust的迭代器是众所周知的。
当实现一个迭代器时，程序员会给它的所有者做一个单独的类型，有一定的生命周期，并实现<code>Iterator</code>trait。</p>
<p>下面是在Rust中对<code>DBM</code>进行迭代的方法:</p>
<pre><code class="language-rust ignore">struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys&lt;'it&gt;(&amp;'it self) -&gt; DbmKeysIter&lt;'it&gt; { ... }
    /* ... */
}

struct DbmKeysIter&lt;'it&gt; {
    owner: &amp;'it Dbm,
}

impl&lt;'it&gt; Iterator for DbmKeysIter&lt;'it&gt; { ... }
</code></pre>
<p>由于Rust的保证，这样做是干净的、习惯性的，而且是安全的。
然而，考虑一下一个直接的API翻译会是什么样子:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_new(owner: *const Dbm) -&gt; *mut DbmKeysIter {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -&gt; libc::c_int {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern &quot;C&quot; fn dbm_iter_del(*mut DbmKeysIter) {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
</code></pre>
<p>这个API丢失了一个关键信息：迭代器的生命周期不能超过拥有它的<code>Dbm</code>对象的生命周期。
库的用户可以使用它，使迭代器的生命周期超过它所迭代的数据，从而导致读取未初始化的内存。</p>
<p>这个用C语言编写的例子包含一个错误，将在后面解释：</p>
<pre><code class="language-C">int count_key_sizes(DBM *db) {
    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &amp;key)) &gt;= 0) { // an error is indicated by -1
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // end of the iterator
            dbm_close(owner);
        }
    }
    if l &gt;= 0 {
        return -1;
    } else {
        return len;
    }
}
</code></pre>
<p>这是一个经典bug。下面是迭代器返回迭代结束标记时的情况：</p>
<ol>
<li>循环条件将<code>l</code>设置为0，并进入循环，因为<code>0 &gt;= 0</code>。</li>
<li>长度递增，但在此情况下为0。</li>
<li>if语句为真，所以数据库被关闭。这里应该有一个break语句。</li>
<li>循环条件再次执行，引起对已关闭对象的<code>next</code>调用。</li>
</ol>
<p>这个错误最糟糕的地方是什么？
如果Rust的实现很小心的话，这段代码在大多数时候都能正常工作!
如果<code>Dbm</code>对象的内存没有被立即重用，内部检查几乎肯定会失败，导致迭代器返回一个<code>-1</code>表示错误。 
但偶尔也会造成段错误，甚至更糟糕的是，会造成无意义的内存损坏！</p>
<p>这些都不是Rust所能避免的。
从它的角度来看，它把这些对象放在了它的堆上，返回了它们的指针，并放弃了对它们生命周期的控制。
C语言的代码只是必须“玩得好”。</p>
<p>程序员必须阅读和理解API文档。
虽然有些人认为这在C语言中是理所当然的，但一个好的API设计可以减轻这种风险。
<code>DBM</code>的POSIX API通过将迭代器的所有权与它的父级合并来做到这一点。</p>
<pre><code class="language-C">datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
</code></pre>
<p>因此，所有的生命周期都被捆绑在一起，避免了不安全因素。</p>
<h2 id="劣势-18"><a class="header" href="#劣势-18">劣势</a></h2>
<p>然而，这种设计选择也有一些缺点，也应予以考虑。</p>
<p>首先，API本身变得不那么具有表达性。
在POSIX DBM中，每个对象只有一个迭代器，而且每次调用都会改变其状态。
这比几乎所有语言中的迭代器都要限制得多，尽管它是安全的。
也许对于其他相关的对象，其生命周期没有那么多层次，这种限制比安全性更有代价。</p>
<p>其次，根据API各部分的关系，可能会涉及大量的设计工作。
许多比较容易的设计点都有其他模式与之相关：</p>
<ul>
<li>
<p><a href="patterns/ffi/./wrappers.html">类型合并</a>将多个Rust类型组合成一个不透明的“对象”。</p>
</li>
<li>
<p><a href="patterns/ffi/../../idioms/ffi/errors.html">FFI 错误传递</a>解释了用整数值和哨兵返回值（如<code>NULL</code>指针）的错误处理。</p>
</li>
<li>
<p>[接受外部字符串]](../../idioms/ffi/accepting-strings.md)允许以最小的不安全代码接受字符串，并且比<a href="patterns/ffi/../../idioms/ffi/passing-strings.html">向FFI传递字符串</a>更容易做对。</p>
</li>
</ul>
<p>然而，并不是每个API都可以这样做。
至于谁是他们的受众，则取决于程序员的最佳判断。</p>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型合并"><a class="header" href="#类型合并">类型合并</a></h1>
<h2 id="描述-27"><a class="header" href="#描述-27">描述</a></h2>
<p>这种模式的设计是为了允许优雅地处理多个相关类型，同时最大限度地减少内存不安全的表面积。</p>
<p>Rust的别名规则的基石之一是生命周期。
这确保了类型之间的许多访问模式都是内存安全的，包括数据竞争安全。</p>
<p>然而，当Rust类型被输出到其他语言时，它们通常被转化为指针。
在Rust中，指针意味着“用户管理着被指向者的生命周期”。
避免内存不安全是他们的责任。</p>
<p>因此需要对用户的代码有一定程度的信任，特别是在Rust无能为力的释放后使用方面。
然而，有些API设计对另一种语言编写的代码造成的负担比其他设计更重。</p>
<p>风险最低的API是“综合封装”，即与一个对象的所有可能的交互都被放入一个“封装器类型”中，保持着Rust API的整洁。</p>
<h2 id="代码示例-4"><a class="header" href="#代码示例-4">代码示例</a></h2>
<p>为了理解这一点，让我们看一下导出API的一个经典例子：通过一个集合进行迭代。</p>
<p>该API看起来像这样：</p>
<ol>
<li>迭代器被初始化为<code>first_key</code>。</li>
<li>每次调用`next_key'将推进迭代器。</li>
<li>如果迭代器在最后，调用<code>next_key</code>将不做任何事情。</li>
<li>如上所述，迭代器被“包裹”在集合中（与原始Rust API不同）。</li>
</ol>
<p>如果迭代器高效地实现了<code>nth()</code>，那么就有可能使它对每个函数的调用都是短暂的：</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}
</code></pre>
<p>这个封装器很简单，不包含任何<code>不安全</code>的代码。</p>
<h2 id="优势-19"><a class="header" href="#优势-19">优势</a></h2>
<p>这使得API的使用更加安全，避免了类型之间的生命周期问题。
参见<a href="patterns/ffi/./export.html">基于对象的API</a>以了解更多关于这样做的好处和避免的陷阱。</p>
<h2 id="劣势-19"><a class="header" href="#劣势-19">劣势</a></h2>
<p>通常情况下，封装类型是相当困难的，有时Rust API的妥协会使事情变得更容易。</p>
<p>举个例子，考虑一个迭代器，它不能高效地实现<code>nth()</code>。
这绝对值得放入特殊的逻辑，使对象在内部处理迭代，或者高效地支持不同的只有外部函数API才会使用的访问模式。</p>
<h3 id="尝试封装迭代器失败"><a class="header" href="#尝试封装迭代器失败">尝试封装迭代器（失败）</a></h3>
<p>为了将任何类型的迭代器正确地封装到API中，封装器需要做C版本的代码会做的事情：擦除迭代器的生命周期，并手动管理它。</p>
<p>可以说，这是<em>相当</em>难的事情。</p>
<p>这里只是说明了<em>一个</em>陷阱。</p>
<p><code>MySetWrapper</code>的第一个版本看起来像这样：</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // created from a transmuted Box&lt;KeysIter + 'self&gt;
    iterator: Option&lt;NonNull&lt;KeysIter&lt;'static&gt;&gt;&gt;,
}
</code></pre>
<p>用<code>transmute</code>来延长生命周期，用指针来隐藏它，这已经很难看了。
但它变得更加糟糕：<em>任何其他操作都会导致Rust的“未定义行为”</em>。</p>
<p>考虑到在迭代过程中，封装器中的<code>MySet</code>可以被其他函数操作，比如为它所迭代的键存储一个新的值。
API并不鼓励这样做，但事实上，一些类似的C库期望这样做。</p>
<p><code>myset_store</code>的一个简单实现：</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub fn myset_store(
        myset: *mut MySetWrapper,
        key: datum,
        value: datum) -&gt; libc::c_int {

        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.

        let myset: &amp;mut MySet = unsafe { // SAFETY: whoops, UB occurs in here!
            &amp;mut (*myset).myset
        };

        /* ...check and cast key and value data... */

        match myset.store(casted_key, casted_value) {
            Ok(_) =&gt; 0,
            Err(e) =&gt; e.into()
        }
    }
}
</code></pre>
<p>如果这个迭代器在这个函数被调用时存在，我们就违反了Rust的别名规则之一。 
根据Rust的规定，这个块中的可变引用必须对该对象有<em>排他性</em>的访问。
如果迭代器仅仅存在，它就不是排他性的，所以我们有“未定义的行为”！<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>为了避免这种情况，我们必须有一种方法来确保可变引用真的是独占的。
这基本上意味着在迭代器的共享引用存在时将其清除，然后再重建它。
在大多数情况下，这仍然会比C版本的效率低。</p>
<p>有些人可能会问：C语言怎么能更有效地做到这一点？
答案是，它作弊了。Rust的别名规则是问题所在，而C只是简单地为了它的指针忽略这些问题。
作为交换，我们经常可以看到在手册中声明在某些或所有情况下“非线程安全”的代码。
事实上，<a href="https://manpages.debian.org/buster/manpages/attributes.7.en.html">GNU C library</a>有一整个词库专门讨论并发行为！</p>
<p>Rust宁愿让所有的内存都是安全的，既为了安全，也为了优化，这是C代码无法达到的。
被拒绝使用某些捷径是Rust程序员需要付出的代价。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>对于那些迷惑不解的C程序员来说，迭代器不需要在这段引起未定义行为的代码中被读取。排他性规则也使编译器优化可能导致迭代器的共享引用出现不一致的观察（例如堆栈溢出或为提高效率而重新排序的指令）。
这些观察可能发生在可变引用创建后的<em>任何时间</em>。</p>
</div>
<blockquote>
<p>Latest commit 606bcff on 26 Feb 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反面模式"><a class="header" href="#反面模式">反面模式</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Anti-pattern">反面模式</a>是一种解决反复出现的问题的方法，通常是无效的，并有可能产生很大的反面作用。与知道如何解决一个问题一样有价值的是知道<strong>不能</strong>这样解决这个问题。相对于设计模式，反面模式给我们提供了很好的反例来考虑。反面模式并不局限于代码。例如，一个流程也可以是一个反面模式。</p>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过clone来满足借用检查器"><a class="header" href="#通过clone来满足借用检查器">通过Clone来满足借用检查器</a></h1>
<h2 id="描述-28"><a class="header" href="#描述-28">描述</a></h2>
<p>借用检查器通过确保以下两种情况来防止Rust用户开发不安全的代码：只存在一个可变引用，或者可能存在多个但都是不可变引用。
如果编写的代码不符合这些条件，当开发者通过克隆变量来解决编译器错误时，就会出现这种反面模式。</p>
<h2 id="例子-22"><a class="header" href="#例子-22">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &amp;mut (x.clone());

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<h2 id="动机-17"><a class="header" href="#动机-17">动机</a></h2>
<p>特别是对初学者来说，用这种模式来解决借用检查器的迷惑问题是很诱人的。
然而，这有严重的后果。使用<code>.clone()</code>会导致数据被复制。
两者之间的任何变化都是不同步的——就像存在两个完全独立的变量一样。</p>
<p>有一些特殊情况——<code>Rc&lt;T&gt;</code>被设计用来智能地处理克隆。
它在内部精确地管理着一份数据的副本，克隆它只会克隆引用。</p>
<p>还有<code>Arc&lt;T&gt;</code>，它提供了在堆中分配的T类型的值的共享所有权。
对<code>Arc</code>调用<code>.clone()</code>会产生一个新的<code>Arc</code>实例，它指向与源<code>Arc</code>相同的堆上的分配，同时增加一个引用计数。</p>
<p>一般来说，克隆应该是深思熟虑的，并充分了解后果。
如果克隆被用来使借用检查器的错误消失，那就很可能说明这种反面模式可能在使用。</p>
<p>尽管<code>.clone()</code>暗示着不好的模式，但有时<strong>写低效的代码也是可以的</strong>，例如在以下情况下：</p>
<ul>
<li>开发者仍然对所有权不熟悉</li>
<li>代码没有很大的速度或内存限制（如黑客马拉松项目或原型）</li>
<li>满足借用检查器相当复杂，而你更愿意优化可读性而不是性能</li>
</ul>
<p>如果怀疑有不必要的克隆，在评估是否需要克隆之前，应该充分理解<a href="https://doc.rust-lang.org/book/ownership.html">Rust Book的所有权章节</a></p>
<p>此外，请确保在你的项目中始终运行<code>cargo clippy</code>，它将检测到一些不需要<code>.clone()</code>的情况，例如<a href="https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone">1</a>,
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy">2</a>,
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#map_clone">3</a>或<a href="https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref">4</a>.</p>
<h2 id="参见-19"><a class="header" href="#参见-19">参见</a></h2>
<ul>
<li><a href="anti_patterns/../idioms/mem-replace.html">在发生改变的枚举中使用<code>mem::{take(_), replace(_)}</code>来保留所有值</a></li>
<li><a href="http://doc.rust-lang.org/std/rc/"><code>Rc&lt;T&gt;</code>文档，用于智能地处理.clone()</a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code>文档，线程安全的引用计数指针</a></li>
<li><a href="https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html">Rust中关于所有权的技巧</a></li>
</ul>
<blockquote>
<p>Latest commit 9834f57 on 25 Aug 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="denywarnings"><a class="header" href="#denywarnings"><code>#![deny(warnings)]</code></a></h1>
<h2 id="描述-29"><a class="header" href="#描述-29">描述</a></h2>
<p>一个善意的crate作者想确保他们的代码在构建时不会出现警告。所以他用以下内容来注释其crate根。</p>
<h2 id="例子-23"><a class="header" href="#例子-23">例子</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>#![deny(warnings)]

<span class="boring">fn main() {
</span>// All is well.
<span class="boring">}
</span></code></pre></pre>
<h2 id="优势-20"><a class="header" href="#优势-20">优势</a></h2>
<p>注释很短，如果出现错误，会停止构建。</p>
<h2 id="劣势-20"><a class="header" href="#劣势-20">劣势</a></h2>
<p>通过不允许编译器产生构建警告，crate作者失去了Rust引以为傲的稳定性。 
有时，新特性或旧的错误特性需要改变处理逻辑，因此，在转为<code>deny</code>之前，会有<code>warn</code>的lint，并有一定的缓冲期。</p>
<p>例如，人们发现一个类型可以有两个具有相同方法的<code>impl</code>块。
这被认为是一个坏主意，但为了使过渡顺利，<code>overlapping-inherent-impls</code> lint被引入，给那些偶然发现这个事实的人一个警告，即使它在未来的版本中将成为一个硬编码错误。</p>
<p>另外，有时API会被废弃，所以在它们消失前使用会发出警告。</p>
<p>当某些事情发生改变，所有这些都有潜在的破坏构建的可能性。</p>
<p>此外，提供额外lint的crate（例如<a href="https://github.com/Manishearth/rust-clippy">rust-clippy</a>）不能再被使用，除非注释被删除。这可以通过[-cap-lints]来缓解。
命令行参数<code>--cap-lints=warn</code>可将所有<code>deny</code>lint错误变成警告。</p>
<h2 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h2>
<p>有两种方法可以解决这个问题：第一，我们可以将构建设置与代码解耦；第二，我们可以指明我们想要显式拒绝的lint。</p>
<p>下面的命令行参数在所有警告设置为<code>deny</code>的情况下构建：</p>
<p><code>RUSTFLAGS=&quot;-D warnings&quot; cargo build</code></p>
<p>这可以由任何个人开发者完成（或者在Travis这样的CI工具中设置，但请记住，当有变化时，这可能会破坏构建），而不需要对代码进行修改。</p>
<p>另外，我们可以在代码中指定我们想要<code>deny</code>的lint。
下面是一个（希望）可以安全拒绝的警告lint的列表（截至Rustc 1.48.0）:</p>
<pre><code class="language-rust ignore">#[deny(bad-style,
       const-err,
       dead-code,
       improper-ctypes,
       non-shorthand-field-patterns,
       no-mangle-generic-items,
       overflowing-literals,
       path-statements ,
       patterns-in-fns-without-body,
       private-in-public,
       unconditional-recursion,
       unused,
       unused-allocation,
       unused-comparisons,
       unused-parens,
       while-true)]
</code></pre>
<p>此外，以下<code>allow</code>lint可能是一个<code>deny</code>的好主意。</p>
<pre><code class="language-rust ignore">#[deny(missing-debug-implementations,
       missing-docs,
       trivial-casts,
       trivial-numeric-casts,
       unused-extern-crates,
       unused-import-braces,
       unused-qualifications,
       unused-results)]
</code></pre>
<p>有些人可能还想在他们的列表中加入<code>missing-copy-implementations</code>lint。</p>
<p>请注意，我们没有明确添加<code>deprecated</code>的lint，因为可以肯定的是，未来会有更多被废弃的API。</p>
<h2 id="参见-20"><a class="header" href="#参见-20">参见</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master">所有的clippy lints</a></li>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#deprecation">deprecate attribute</a>文档</li>
<li>输入<code>rustc -W help</code>可查看你系统上的lint。也可以输入
<code>rustc --help</code>查看选项。</li>
<li><a href="https://github.com/Manishearth/rust-clippy">rust-clippy</a>是一个用于写出更好的Rust代码的lint集合。</li>
</ul>
<blockquote>
<p>Latest commit 39a2f36 on 18 Oct 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-多态性"><a class="header" href="#deref-多态性"><code>Deref</code> 多态性</a></h1>
<h2 id="描述-30"><a class="header" href="#描述-30">描述</a></h2>
<p>滥用<code>Deref</code> trait来模拟结构体间的继承，从而重用方法。</p>
<h2 id="例子-24"><a class="header" href="#例子-24">例子</a></h2>
<p>有时我们想模仿以下来自OO语言（如Java）的常见模式：</p>
<pre><code class="language-java">class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
</code></pre>
<p>我们可以使用deref多态性的反面模式来做到这一点：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
</code></pre></pre>
<p>Rust中没有结构体的继承。相反，我们使用组合，并在<code>Bar</code>中包含一个<code>Foo</code>的实例（因为字段是一个值，它被内联存储，所以如果有字段，它们在内存中的布局与Java版本相同（可能，如果你想确定，你应该使用<code>#[repr(C)]</code>））。</p>
<p>为了使方法调用生效，我们为<code>Bar</code>实现了<code>Deref</code>，以<code>Foo</code>为目标（返回嵌入的<code>Foo</code>字段）。这意味着当我们解除对<code>Bar</code>的引用时（例如，使用<code>*</code>），我们将得到一个<code>Foo</code>。
这很奇怪。解引用通常从对<code>T</code>的引用中得到一个<code>T</code>，这里我们有两个不相关的类型。
然而，由于点运算符做了隐式解引用，这意味着方法调用将搜索<code>Foo</code>和<code>Bar</code>的方法。</p>
<h2 id="优势-21"><a class="header" href="#优势-21">优势</a></h2>
<p>你可以节省一点模板代码，例如：</p>
<pre><code class="language-rust ignore">impl Bar {
    fn m(&amp;self) {
        self.f.m()
    }
}
</code></pre>
<h2 id="劣势-21"><a class="header" href="#劣势-21">劣势</a></h2>
<p>最重要的是这是一个令人惊讶的惯常做法--未来的程序员在代码中读到这句话时，不会想到会发生这种情况。
这既因为我们在滥用<code>Deref</code> trait，而不是按照预期（文档等）使用它。
也因为这里的机制是完全隐含的。</p>
<p>这种模式没有像Java或C++中的继承那样在<code>Foo</code>和<code>Bar</code>之间引入子类型。此外，由<code>Foo</code>实现的特性不会自动为<code>Bar</code>实现，所以这种模式与边界检查以及泛型编程的互动性很差。</p>
<p>使用这种模式，在<code>self</code>的语义上与大多数OO语言有细微的不同。
通常情况下，它仍然是对子类的引用，在这种模式下，它将是定义方法的&quot;类&quot;。</p>
<p>最后，这种模式只支持单继承，没有接口的概念，没有基于类的隐私，也没有其他与继承有关的特性。
所以，它给人的体验会让习惯了Java继承等的程序员感到微妙的惊讶。</p>
<h2 id="讨论-15"><a class="header" href="#讨论-15">讨论</a></h2>
<p>我们没有一个好的替代方案。根据具体的情况，使用traits重新实现或者手动写出派发给<code>Foo</code>的facade方法可能更好。
我们确实打算在Rust中加入与此类似的继承机制，但要达到稳定的Rust，可能还需要一些时间。详情可见：
<a href="http://aturon.github.io/blog/2015/09/18/reuse/">blog</a>
<a href="http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/">posts</a>
and this <a href="https://github.com/rust-lang/rfcs/issues/349">RFC issue</a></p>
<p><code>Deref</code> trait 是为实现自定义指针类型而设计的。
目的是让它通过指向<code>T</code>的指针到达<code>T</code>，而不是在不同类型之间转换。
遗憾的是，这一点并没有（也许不能）由trait定义强制执行。</p>
<p>Rust试图在显式和隐式机制之间取得谨慎的平衡，倾向于类型之间的显式转换。
点运算符中的自动解引用是一个人机工程学强烈支持隐式机制的情况，但其目的是将其限制在间接程度上，而不是在任意类型之间的转换。</p>
<h2 id="参见-21"><a class="header" href="#参见-21">参见</a></h2>
<ul>
<li><a href="anti_patterns/../idioms/deref.html">集合是智能指针的惯常做法</a>.</li>
<li>为了较少的模板代码的代表crate <a href="https://crates.io/crates/delegate">delegate</a>
或<a href="https://crates.io/crates/ambassador">ambassador</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code> trait文档</a>.</li>
</ul>
<blockquote>
<p>Latest commit fb57f21 on 10 Mar 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust的函数式用法"><a class="header" href="#rust的函数式用法">Rust的函数式用法</a></h1>
<p>Rust是一种命令式语言，但它遵循许多<a href="https://en.wikipedia.org/wiki/Functional_programming">函数式编程</a>的范式。</p>
<blockquote>
<p>在计算机科学中，<em>函数式编程</em>是通过应用和组合函数构建程序的一种编程范式。
它是一种声明式编程范式，其中函数定义是表达式树，每个表达式返回一个值，而不是改变程序状态的命令式语句序列。</p>
</blockquote>
<blockquote>
<p>Latest commit c41be87 on 20 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程范式"><a class="header" href="#编程范式">编程范式</a></h1>
<p>理解函数式程序的最大障碍之一是命令式程序背景下的思维转变。
命令式程序描述的是<strong>如何</strong>做某事，而声明式程序描述的是<strong>什么</strong>做什么。
让我们把1到10的数字相加来说明这一点。</p>
<h2 id="命令式"><a class="header" href="#命令式">命令式</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!(&quot;{}&quot;, sum);
<span class="boring">}
</span></code></pre></pre>
<p>对于命令式程序，我们必须模拟编译器来看看发生了什么。
在这里，我们从一个值为<code>0</code>的<code>sum</code>开始。
接下来，我们在1到10的范围内进行迭代。
循环的每一次，我们在范围内加上相应的值。
最后我们把它打印出来。</p>
<table><thead><tr><th align="center"><code>i</code></th><th align="center"><code>sum</code></th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<p>这就是我们大多数人开始编程的方式。
我们知道，一个程序就是一个步骤的集合。</p>
<h2 id="声明式"><a class="header" href="#声明式">声明式</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (1..11).fold(0, |a, b| a + b));
<span class="boring">}
</span></code></pre></pre>
<p>哇! 这真的很不一样! 这里发生了什么？
请记住，在声明性程序中，我们描述的是<strong>做什么</strong>，而不是<strong>如何</strong>做它。
<code>fold</code>是一个可以<a href="https://en.wikipedia.org/wiki/Function_composition">组合</a>函数的函数。
这个名字是来自Haskell的一个惯例。</p>
<p>在这里，我们正在组成加法的函数（闭包：<code>|a, b| a + b</code>），范围是从1到10。
<code>0</code>是起点，所以<code>a</code>一开始就是<code>0</code>。
<code>b</code>是范围的第一个元素，<code>1</code>。<code>0 + 1 = 1</code>是结果。
所以现在我们再次<code>fold</code>，<code>a = 1</code>，<code>b = 2</code>，所以<code>1 + 2 = 3</code>是下一个结果。
这个过程一直持续到我们得到范围内的最后一个元素，<code>10</code>。</p>
<table><thead><tr><th align="center"><code>a</code></th><th align="center"><code>b</code></th><th align="center">result</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr>
<tr><td align="center">3</td><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">6</td><td align="center">4</td><td align="center">10</td></tr>
<tr><td align="center">10</td><td align="center">5</td><td align="center">15</td></tr>
<tr><td align="center">15</td><td align="center">6</td><td align="center">21</td></tr>
<tr><td align="center">21</td><td align="center">7</td><td align="center">28</td></tr>
<tr><td align="center">28</td><td align="center">8</td><td align="center">36</td></tr>
<tr><td align="center">36</td><td align="center">9</td><td align="center">45</td></tr>
<tr><td align="center">45</td><td align="center">10</td><td align="center">55</td></tr>
</tbody></table>
<blockquote>
<p>Latest commit 2cd70a5 on 22 Jan 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作为类型类的泛型"><a class="header" href="#作为类型类的泛型">作为类型类的泛型</a></h1>
<h2 id="描述-31"><a class="header" href="#描述-31">描述</a></h2>
<p>Rust的类型系统设计得更像函数式语言（如Haskell）而不是命令式语言（如Java和C++）。
因此，Rust可以把许多类型的编程问题变成“静态类型”问题。
这是选择函数式语言的最大优势之一，对Rust的许多编译时保证至关重要。</p>
<p>这个想法的一个关键部分是泛型的工作方式。例如，在C++和Java中，泛型是编译器的一个元编程结构。
C++中的<code>vector&lt;int&gt;</code>和<code>vector&lt;char&gt;</code>只是一个<code>vector</code>类型（被称为<code>template</code>）的相同模板代码的两个不同副本，其中填入了两种不同类型。</p>
<p>在Rust中，泛型参数创建了函数式语言中所谓的“类型类约束”，用户填写的每个不同的参数<em>实际上都会改变类型</em>。
换句话说，<code>Vec&lt;isize&gt;</code>和<code>Vec&lt;char&gt;</code><em>是两种不同的类型</em>，被类型系统的所有部分识别为不同的类型。</p>
<p>这被称为<strong>单态化</strong>，不同的类型由<strong>多态的</strong>代码创建。 
这种特殊的行为需要<code>impl</code>块来指定泛型参数：泛型的不同值会导致不同的类型，而不同的类型可以有不同的<code>impl</code>块。</p>
<p>在面向对象的语言中，类可以从其父辈那里继承行为。
然而，这不仅允许将额外的行为附加到类型类的特定成员上，而且还允许附加到额外的行为上。</p>
<p>最接近的是Javascript和Python中的运行时多态性，在那里，新的成员可以被任意构造器随意地添加到对象中。
然而，与这些语言不同的是，Rust的所有额外方法在使用时都可以被类型检查，因为它们的泛型是静态定义的。
这使得它们在保持安全的同时更具有实用性。</p>
<h2 id="例子-25"><a class="header" href="#例子-25">例子</a></h2>
<p>假设你正在为一系列的实验室机器设计一个存储服务器。
由于涉及到软件，有两个不同的协议需要你支持。BOOTP（用于PXE网络启动），和NFS（用于远程挂载存储）。</p>
<p>你的目标是有一个用Rust编写的程序，可以处理这两个协议。
它将有协议处理器，并监听两种请求。
然后，主要的应用逻辑将允许实验室管理员为实际文件配置存储和安全控制。</p>
<p>实验室里的机器对文件的请求包含相同的基本信息，无论它们来自什么协议：一个认证方法，和一个要检索的文件名。 
一个直接的实现会是这样的：</p>
<pre><code class="language-rust ignore">
enum AuthInfo {
    Nfs(crate::nfs::AuthInfo),
    Bootp(crate::bootp::AuthInfo),
}

struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
}
</code></pre>
<p>这种设计可能工作得足够好。
但现在假设你需要支持添加<em>协议特定</em>的元数据。
例如，对于NFS，你想确定他们的挂载点是什么，以便强制执行额外的安全规则。</p>
<p>当前结构体的设计方式将协议决定权留给了运行时。
这意味着任何适用于一种协议而不适用于另一种协议的方法都需要程序员在进行运行时检查。</p>
<p>以下是获得NFS挂载点的代码：</p>
<pre><code class="language-rust ignore">struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
    mount_point: Option&lt;PathBuf&gt;,
}

impl FileDownloadRequest {
    // ... other methods ...

    /// Gets an NFS mount point if this is an NFS request. Otherwise,
    /// return None.
    pub fn mount_point(&amp;self) -&gt; Option&lt;&amp;Path&gt; {
        self.mount_point.as_ref()
    }
}
</code></pre>
<p><code>mount_point()</code>的每个调用者都必须检查<code>None</code>并编写代码来处理它。
即使他们知道在给定的代码路径中只有NFS请求会被使用。</p>
<p>如果不同的请求类型被混淆，产生编译时错误会更理想。
毕竟，用户的整个代码路径，包括他们使用库中的哪些函数，都会知道一个请求是NFS请求还是BOOTP请求。</p>
<p>在Rust中，这其实是可以做到的! 解决办法是<em>添加一个泛型</em>，以便分割API。</p>
<p>下面是它的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::path::{Path, PathBuf};

mod nfs {
    #[derive(Clone)]
    pub(crate) struct AuthInfo(String); // NFS session management omitted
}

mod bootp {
    pub(crate) struct AuthInfo(); // no authentication in bootp
}

// private module, lest outside users invent their own protocol kinds!
mod proto_trait {
    use std::path::{Path, PathBuf};
    use super::{bootp, nfs};

    pub(crate) trait ProtoKind {
        type AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo;
    }

    pub struct Nfs {
        auth: nfs::AuthInfo,
        mount_point: PathBuf,
    }

    impl Nfs {
        pub(crate) fn mount_point(&amp;self) -&gt; &amp;Path {
            &amp;self.mount_point
        }
    }

    impl ProtoKind for Nfs {
        type AuthInfo = nfs::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            self.auth.clone()
        }
    }

    pub struct Bootp(); // no additional metadata

    impl ProtoKind for Bootp {
        type AuthInfo = bootp::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            bootp::AuthInfo()
        }
    }
}

use proto_trait::ProtoKind; // keep internal to prevent impls
pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them

struct FileDownloadRequest&lt;P: ProtoKind&gt; {
    file_name: PathBuf,
    protocol: P,
}

// all common API parts go into a generic impl block
impl&lt;P: ProtoKind&gt; FileDownloadRequest&lt;P&gt; {
    fn file_path(&amp;self) -&gt; &amp;Path {
        &amp;self.file_name
    }

    fn auth_info(&amp;self) -&gt; P::AuthInfo {
        self.protocol.auth_info()
    }
}

// all protocol-specific impls go into their own block
impl FileDownloadRequest&lt;Nfs&gt; {
    fn mount_point(&amp;self) -&gt; &amp;Path {
        self.protocol.mount_point()
    }
}

fn main() {
    // your code here
}
</code></pre></pre>
<p>采用这种方法，如果用户使用了错误的类型：</p>
<pre><code class="language-rust ignore">fn main() {
    let mut socket = crate::bootp::listen()?;
    while let Some(request) = socket.next_request()? {
        match request.mount_point().as_ref()
            &quot;/secure&quot; =&gt; socket.send(&quot;Access denied&quot;),
            _ =&gt; {} // continue on...
        }
        // Rest of the code here
    }
}
</code></pre>
<p>他们会得到一个语法错误。
<code>FileDownloadRequest&lt;Bootp&gt;</code>类型没有实现<code>mount_point()</code>，只有<code>FileDownloadRequest&lt;Nfs&gt;</code>类型实现。
而这是由NFS模块创建的，当然不是BOOTP模块!</p>
<h2 id="优势-22"><a class="header" href="#优势-22">优势</a></h2>
<p>首先，它允许在多个状态下共有的字段被去掉重复。
通过使共享字段泛型化，保证其只被实现一次。</p>
<p>其次，它使<code>impl</code>块更容易阅读，因为它们是按状态分解的。
所有状态下通用的方法只在一个块中出现，而一个状态下特有的方法则在单独的块中出现。</p>
<p>这两点都意味着代码行数更少，而且组织得更好。</p>
<h2 id="劣势-22"><a class="header" href="#劣势-22">劣势</a></h2>
<p>目前这增加了二进制文件的大小，这是由于编译器中实现单态化的方式造成的。
希望这种实现方式在未来能够得到改善。</p>
<h2 id="替代方案-1"><a class="header" href="#替代方案-1">替代方案</a></h2>
<ul>
<li>
<p>如果一个类型由于构造或部分初始化而似乎需要一个“分开的API”，可以考虑用<a href="functional/../patterns/creational/builder.html">生成器模式</a>来代替。</p>
</li>
<li>
<p>如果类型之间的API不发生变化——只有行为发生变化——那么最好使用<a href="functional/../patterns/behavioural/strategy.html">策略模式</a>代替。</p>
</li>
</ul>
<h2 id="参见-22"><a class="header" href="#参见-22">参见</a></h2>
<p>这种模式在整个标准库中都被使用：</p>
<ul>
<li><code>Vec&lt;u8&gt;</code>可以从一个字符串中转换出，与其他类型的<code>Vec&lt;T&gt;</code>不同。<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>当它们只包含一个实现了<code>Ord</code>trait的类型时，它们也可以被转换到二叉堆中。<sup class="footnote-reference"><a href="#2">2</a></sup></li>
<li><code>to_string</code>方法是只针对<code>str</code>类型的<code>Cow</code>。<sup class="footnote-reference"><a href="#3">3</a></sup></li>
</ul>
<p>它也被几个流行的crate使用，以允许API的灵活性:</p>
<ul>
<li>
<p>用于嵌入式设备的<code>embedded-hal</code>生态系统广泛使用了这种模式。
例如，它允许静态地验证用于控制嵌入式引脚的设备寄存器的配置。
当一个引脚进入一个模式时，它返回一个<code>Pin&lt;MODE&gt;</code>结构体，其泛型决定了在该模式下可用的功能，这些功能不在<code>Pin</code>本身上。<sup class="footnote-reference"><a href="#4">4</a></sup></p>
</li>
<li>
<p><code>hyper</code>HTTP客户端库利用这一点为不同的可插拔请求提供了丰富的API。
不同连接器的客户端有不同的方法以及不同的trait实现，而一组核心方法适用于任何连接器。<sup class="footnote-reference"><a href="#5">5</a></sup></p>
</li>
<li>
<p>“类型状态”模式——对象根据内部状态或不变量获得和失去API——在Rust中使用相同的基本概念和稍微不同的技术来实现。<sup class="footnote-reference"><a href="#6">6</a></sup></p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://doc.rust-lang.org/stable/src/std/ffi/c_str.rs.html#799-801">impl From&lt;CString&gt; for Vec&lt;u8&gt;</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354">impl&lt;T&gt; From&lt;Vec&lt;T, Global&gt;&gt; for BinaryHeap&lt;T&gt;</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235-2240">impl&lt;'_&gt; ToString for Cow&lt;'_, str&gt;</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html">https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><a href="https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html">https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><a href="https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-pattern-itself/">类型状态模式的例子</a>和<a href="https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index">Rusty Typestate系列（一篇扩展论文）</a></p>
</div>
<blockquote>
<p>Latest commit 7e96169 on 15 Sep 2021</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h1>
<p>A collection of complementary helpful content</p>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=Pm_oO0N5B9k">Design Patterns in Rust</a> by
Nicholas Cameron at the PDRust (2016)</li>
<li><a href="https://www.youtube.com/watch?v=0zOg8_B71gE">Writing Idiomatic Libraries in Rust</a>
by Pascal Hertleif at RustFest (2017)</li>
<li><a href="https://www.youtube.com/watch?v=vqavdUGKeb4">Rust Programming Techniques</a> by
Nicholas Cameron at LinuxConfAu (2018)</li>
</ul>
<h2 id="books-online"><a class="header" href="#books-online">Books (Online)</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines">The Rust API Guidelines</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h1>
<h2 id="a-brief-overview-over-common-design-principles"><a class="header" href="#a-brief-overview-over-common-design-principles">A brief overview over common design principles</a></h2>
<hr />
<h2 id="a-hrefhttpsenwikipediaorgwikisolidsolida"><a class="header" href="#a-hrefhttpsenwikipediaorgwikisolidsolida"><a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle (SRP)</a>:
A class should only have a single responsibility, that is, only changes to
one part of the software's specification should be able to affect the
specification of the class.</li>
<li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open/Closed Principle (OCP)</a>:
&quot;Software entities ... should be open for extension, but closed for
modification.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle (LSP)</a>:
&quot;Objects in a program should be replaceable with instances of their subtypes
without altering the correctness of that program.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle (ISP)</a>:
&quot;Many client-specific interfaces are better than one general-purpose
interface.&quot;</li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle (DIP)</a>:
One should &quot;depend upon abstractions, [not] concretions.&quot;</li>
</ul>
<h2 id="a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikidon27t_repeat_yourselfdry-dont-repeat-yourselfa"><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don’t Repeat Yourself)</a></a></h2>
<p>&quot;Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system&quot;</p>
<h2 id="a-hrefhttpsenwikipediaorgwikikiss_principlekiss-principlea"><a class="header" href="#a-hrefhttpsenwikipediaorgwikikiss_principlekiss-principlea"><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a></a></h2>
<p>most systems work best if they are kept simple rather than made complicated;
therefore, simplicity should be a key goal in design, and unnecessary
complexity should be avoided</p>
<h2 id="a-hrefhttpsenwikipediaorgwikilaw_of_demeterlaw-of-demeter-loda"><a class="header" href="#a-hrefhttpsenwikipediaorgwikilaw_of_demeterlaw-of-demeter-loda"><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter (LoD)</a></a></h2>
<p>a given object should assume as little as possible about the structure or
properties of anything else (including its subcomponents), in accordance with
the principle of &quot;information hiding&quot;</p>
<h2 id="a-hrefhttpsenwikipediaorgwikidesign_by_contractdesign-by-contract-dbca"><a class="header" href="#a-hrefhttpsenwikipediaorgwikidesign_by_contractdesign-by-contract-dbca"><a href="https://en.wikipedia.org/wiki/Design_by_contract">Design by contract (DbC)</a></a></h2>
<p>software designers should define formal, precise and verifiable interface
specifications for software components, which extend the ordinary definition of
abstract data types with preconditions, postconditions and invariants</p>
<h2 id="a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programmingencapsulationa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikiencapsulation_computer_programmingencapsulationa"><a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a></a></h2>
<p>bundling of data with the methods that operate on that data, or the restricting
of direct access to some of an object's components. Encapsulation is used to
hide the values or state of a structured data object inside a class, preventing
unauthorized parties' direct access to them.</p>
<h2 id="a-hrefhttpsenwikipediaorgwikicommande28093query_separationcommand-query-separationcqsa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikicommande28093query_separationcommand-query-separationcqsa"><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command-Query-Separation(CQS)</a></a></h2>
<p>“Functions should not produce abstract side effects...only commands
(procedures) will be permitted to produce side effects.” - Bertrand Meyer:
Object-Oriented Software Construction</p>
<h2 id="a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishmentprinciple-of-least-astonishment-polaa"><a class="header" href="#a-hrefhttpsenwikipediaorgwikiprinciple_of_least_astonishmentprinciple-of-least-astonishment-polaa"><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">Principle of least astonishment (POLA)</a></a></h2>
<p>a component of a system should behave in a way that most users will expect it
to behave. The behavior should not astonish or surprise users</p>
<h2 id="linguistic-modular-units"><a class="header" href="#linguistic-modular-units">Linguistic-Modular-Units</a></h2>
<p>“Modules must correspond to syntactic units in the language used.” - Bertrand
Meyer: Object-Oriented Software Construction</p>
<h2 id="self-documentation"><a class="header" href="#self-documentation">Self-Documentation</a></h2>
<p>“The designer of a module should strive to make all information about the
module part of the module itself.” - Bertrand Meyer: Object-Oriented Software
Construction</p>
<h2 id="uniform-access"><a class="header" href="#uniform-access">Uniform-Access</a></h2>
<p>“All services offered by a module should be available through a uniform
notation, which does not betray whether they are implemented through storage or
through computation.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="single-choice"><a class="header" href="#single-choice">Single-Choice</a></h2>
<p>“Whenever a software system must support a set of alternatives, one and only
one module in the system should know their exhaustive list.” - Bertrand Meyer:
Object-Oriented Software Construction</p>
<h2 id="persistence-closure"><a class="header" href="#persistence-closure">Persistence-Closure</a></h2>
<p>“Whenever a storage mechanism stores an object, it must store with it the
dependents of that object. Whenever a retrieval mechanism retrieves a
previously stored object, it must also retrieve any dependent of that object
that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented Software
Construction</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
